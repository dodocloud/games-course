doctype html
include ./mixins/header.pug
include ./mixins/containers.pug
include ./mixins/containers_aph.pug
include ./mixins/title.pug
include ./mixins/summary.pug

- var themePath = '../themes/aph/';
- var assets = '../assets/';
- var globalAssets = assets +'all/';

html(lang='en')
    +header('Summary', 'Adam Vesecký', themePath + 'resources/favicon.png', themePath + 'theme_aph.scss')

    // ===================================================== SLIDES =====================================================
    .reveal
        .slides
            // ============================================================
            +title('', 'Course Summary')
            - var imgAssets = '../assets/games_intro/';
            +mchapter('Games: What are games', imgAssets+'chapter_game.svg')
            +frameInbox('What is a computer game?')
                div.important-orange
                    .scope.fragment
                        p Computer Application
                        ul
                            li a computer program that <span class="highlight-2">helps</span> a user to perform a task
                    .scope.fragment
                        p Computer game
                        ul
                            li a computer-controller game where players interact with objects displayed on a screen for the sake of <span class="highlight-2">entertainment</span>.
                +tipKeen("Computer games are not applications! Yet the line between them is blurry.")(class='bottom-0p right-30p')

            - var imgAssets = '../assets/games_mechanics/';
            +mchapter('Games: Game Mechanics', imgAssets+'chapter_mechanics.svg')
            +frameInbox('Terms')
                div.important-orange
                    .scope.fragment 
                        p Emergence
                        ul
                            li refers to the fact that the behavior is the result of a complex and dynamic system of rules
                    .scope.fragment 
                        p Progression
                        ul
                            li refers to the structures in games where a designer outlined the possible game states beforehand, usually through level design.
                    .scope.fragment
                        p Gameplay
                        ul
                            li an emergent property of the game as defined by its rules
                    .scope.fragment 
                        p Mechanics
                        ul
                            li a set of rules governing the behavior of a single game element.
                    .scope.fragment 
                        p System
                        ul
                            li interacting group of game elements forming a unified whole
                    .scope.fragment 
                        p Level
                        ul
                            li structure in a game that dictates what challenges players encounter
            +frameInbox('Terms')
                div.important-orange
                    .scope.fragment
                        p Simulation
                        ul
                            li a representation of a source system via a less complex system that correlates with the user's understanding of the source system
                    .scope.fragment
                        p Bot
                        ul
                            li an intelligent artificial player emulating a human player
                    .scope.fragment
                        p Agent
                        ul
                            li an intelligent autonomous entity, having the ability to manipulate its environment
                    .scope.fragment
                        p Mob
                        ul
                            li a generic monster/enemy or a group of monsters
                    .scope.fragment
                        p NPC
                        ul
                            li non-playable character - doesn't play the game but rather interacts with the player
            +frameInbox('Game Basic Elements')
                div.important-orange
                    .scope.fragment
                        p Mechanics
                        ul
                            li a set of rules governing the behavior of a single game element
                    .scope.fragment
                        p Story
                        ul
                            li a sequence of events that unfolds in the game
                    .scope.fragment
                        p Aesthetics
                        ul
                            li how the game looks, sounds, tastes, feels,...
                    .scope.fragment
                        p Technology
                        ul
                            li any materials and interactions that make the game possible
                    .scope.fragment
                        p Goals
                        ul
                            li define what players try to achieve
                    .bottom-40.right-40.fragment
                        img.width-600(src=imgAssets+'visible_mechanics.svg')
            +frameInbox('Game Mechanic Entities')
                div.important-orange
                    .scope.fragment.fade-up
                        p Space
                        ul
                            li various spaces that can exist in a game and how they are related
                            li physical and conceptual relationships
                    .scope.fragment.fade-up
                        p Objects
                        ul
                            li entities that can be seen or manipulated
                    .scope.fragment.fade-up
                        p Actions
                        ul
                            li an object's turn to act
                    .scope.fragment.fade-up
                        p Rules
                        ul
                            li statements that describe constraints, consequences and goals

            - var imgAssets = '../assets/games_engines/';
            +mchapter('Games: Rise of game engines', imgAssets+'chapter_engines.svg')
            +frameInbox('ID Tech')
                div.important-orange
                    ul
                        li Family of game engines developed by ID Software
                        li <span class="highlight">Id Tech 0</span> - the very first game engine
                        li Every next game had more advanced technology
                        li Still, memory constraints sabotaged attempts to create data-heavy design
                    .flex-cols-4.mt-80
                            +floppyApp(imgAssets+'idtech_hovertank.jpg', 'Hovertank 3-D', '1991')
                            +floppyApp(imgAssets+'idtech_catacomb.jpg', 'Catacomb 3-D', '1991')
                            +floppyApp(imgAssets+'idtech_wolfenstein.jpg', 'Wolfenstein 3-D', '1992')
                            +floppyApp(imgAssets+'idtech_shadowcast.jpg', 'Shadowcaster', '1993')
            +frameInbox('Quake Engine')
                div.important-orange
                    .flex-cols-2
                        div
                            ul
                                li ~id Tech 1
                                li Released by ID Software in 1996
                                li True 3D real-time rendering
                                li Binary space partitioning
                                li 3D light sources, Gouraud shading
                                li Games released: <span class="highlight">Quake, Hexen 2, Silver Wings</span>
                                li Source code released in 1999
                            ul
                                li <span class="highlight">Successors:</span>
                                ul
                                    li id Tech 2: 1997
                                    li id Tech 3: 1999
                                    li id Tech 4: 2004
                                    li id Tech 5: 2011
                                    li id Tech 6: 2016
                                    li id Tech 7: 2018
                        div.self-end.text-right
                            img.height-550(src=imgAssets+'idtech_5.jpg')

            +summary_lecture01()

            - var imgAssets = '../assets/engines_intro/';
            +mchapter('Engines: Game Engines Overview', imgAssets+'chapter_engines_intro.svg')
            +frameInbox('Game Engine Primary Modules')
                .important-orange
                    ul
                        li.fragment <span class="highlight">Game Loop</span> - heartbeat of all games
                        li.fragment <span class="highlight">Scene Manager</span> - manages objects and structures them in a scene graph
                        li.fragment <span class="highlight">Resource Manager</span> - manages assets, controls a cache
                        li.fragment <span class="highlight">Input Manager</span> - handles inputs (keyboard, mouse, touch, joystick, gamepad,...)
                        li.fragment <span class="highlight">Memory Manager</span> - memory allocator and deallocator
                        li.fragment <span class="highlight">Rigidbody Engine</span> - event-based collision detection
                        li.fragment <span class="highlight">Physics Engine</span> - handles behavior of objects based on forces and impulses
                        li.fragment <span class="highlight">Rendering Engine</span> - renders the game, takes care of the rendering pipeline 
                        li.fragment <span class="highlight">Animation Engine</span> - handles animations
                        li.fragment <span class="highlight">Scripting Engine</span> - a bridge between the engine and interpreted languages (JS, C#,...)
                        li.fragment <span class="highlight">Audio Engine</span> - plays music, clips, sounds, calculates 3D sound
                        li.fragment <span class="highlight">AI Engine</span> - abstract engine for AI (state machines, behavioral trees,...)
                        li.fragment <span class="highlight">Networking Engine</span> - handles multipeer communication
                    div.fragment
                        ul
                            li Other modules - GUI framework, Level Editor, Camera, Event System, LOD system,...

            - var imgAssets = '../assets/engines_loop/';
            +mchapter('Engines: Game Loop', imgAssets+'chapter_engines_loop.svg')
            +frameInbox('Application and Loop')
                .important-orange.leading-xl
                    .scope.fragment
                        p Initialization process
                        ol
                            li.fragment Initialize engine object
                            li.fragment Register all systems
                            li.fragment Initialize rendering window
                            li.fragment Run game loop
                            li.fragment Terminate
                    .scope.fragment
                        p Game Loop process
                        ol
                            li.fragment Process inputs
                            li.fragment Update game state
                            li.fragment Render game objects
                            li.fragment Repeat
                .bottom-0.right-0
                    img.width-800(src=imgAssets+'hello_world_triangle.png')
            +frameInbox('Game Loop')
                .important-orange
                    ul
                        li simple, yet the most important part of the game engine
                        li each turn advances the state of the game
                        li the loop is usually coordinated with the event loop of the platform/virtual machine
                        li optimal time step for rendering: 
                            span.highlight.font-bold 60 FPS = 16.6 ms per frame
                        li audio and input processing are usually separated as they require more frequent updates
                    .space-2xl
                    .text-center.center.fragment
                        .width-55p.highlight.font-bold In general, a program spends 90% of its time in 10% of its code. The game loop will be firmly in those 10%.
            +frameInbox('Simple Game Loop')
                .important-orange.center.fill
                    img.height-750(src=imgAssets+'loop_simple.svg')
            +frameInbox('Game loop with separated rendering')
                .important-orange.center.fill
                    img.height-750(src=imgAssets+'loop_multithreaded.svg')
            +frameInbox('Cooperative game loop')
                .important-orange
                    ul
                        li implemented by small, relatively independent jobs
                        li.fragment firstly used in <span class="highlight">Ultima VII (1994)</span>
                    .bottom-0.left-100
                        img.height-720(src=imgAssets+'loop_cooperative.svg')
            +frameInbox('Update method')
                .important-red
                    .scope.fragment 
                        p Fixed time step
                        ul
                            li.fragment each update advances game time by a certain amount of time
                            li.upside.fragment precise and stable
                            li.downside.fragment the game may slow down
                    .scope.fragment
                        p Variable time step
                        ul
                            li.fragment each update advances game time based on how much real time passed since the last frame
                            li.upside.fragment natural
                            li.downside.fragment non-deterministic and unstable
                    .scope.fragment
                        p Adaptive time step
                        ul
                            li.fragment switches between variable and fixed time step
                            li.fragment based either on thresholds or a more sophisticated approach
                            li.fragment deals with long breaks better than the other two
                    +tipKeen("Some old games were tied with the system clock, hence their CPU-sensitivity.")(class='bottom-0 right-300')
            +frameInbox('Update Inconsistencies')
                .important-orange
                    ul
                        li.fragment game objects are consistent before and after every update
                        li.fragment they may get to an inconsistent state during update - <span class="highlight">one-frame-off lag</span>
                        li.fragment possible solutions: bucket update, <span class="highlight">script execution order</span> (Unity)
                    .center.fragment
                        figure.width-1000.mt-40
                            img.width-1000(src=imgAssets+'update_inconsistencies.svg')
                            p Object A reads previous state of Object B and Object B reads previous state of Object C
            
            - var imgAssets = '../assets/engines_scene/';
            +mchapter('Engines: Scene Graph', imgAssets+'chapter_engines_scene.svg')
            +frameInbox('Scene Graph')
                .important-orange
                    .scope.fragment
                        p Scene Graph
                        ul
                            li.fragment essential structure of every interactive application
                            li.fragment a way of ordering the data into a hierarchy
                            li.fragment represented as N-Tree or a regular graph
                            li.fragment implemented as an array, oct-tree, quad-tree, bounding volume hierarchy,...
                            li.highlight.fragment parent nodes affect child nodes (translation, rotation, scale,...)
                            li.fragment leaves represent atomic units (shapes, vertices, imported meshes)
                    .scope.fragment
                        p Scene Manager
                        ul
                            li.fragment manages objects in the scene
                            li.fragment similar to HTML DOM along with Event Manager
                            li.fragment responsibility: sending events, searching for objects, applying transformations,...
                            li.fragment Unity Engine - game objects form a hierarchy
                            li.fragment Unreal Engine - components form a hierarchy
                            li.fragment Godot Engine - everyting forms a hierarchy


            - var imgAssets = '../assets/engines_input/';
            +mchapter('Engines: Input', imgAssets+'chapter_engines_input.svg')
            +frameInbox('Input Manager')
                .important-orange
                    p.fragment(data-fragment-index="0") Detects input events from devices
                    .flex-cols-2
                        div
                            .scope.fragment(data-fragment-index="1")
                                p Atomic events
                                ul
                                    li KEY_DOWN
                                    li KEY_UP
                                    li MOUSE_WHEEL
                                    li JOYPAD_A
                            .scope.fragment(data-fragment-index="2")
                                p Compound events
                                ul
                                    li FLING
                                    li PINCH_TO_ZOOM
                                    li DOUBLE_TAP
                            .scope.fragment(data-fragment-index="3")
                                p Special events
                                ul
                                    li cheat codes
                                    li fighting combos
                        div
                            div.text-center.fragment(data-fragment-index="1")
                                img.height-150(src=imgAssets+'input_joypad.png')
                            div.text-center.mt-80.fragment(data-fragment-index="2")
                                img.height-150(src=imgAssets+'input_pinch.png')
                            div.text-center.mt-80.fragment(data-fragment-index="3")
                                img.height-200(src=imgAssets+'input_cheat.png')
            +frameInbox('Input Devices')
                .important-orange
                    .flex.flex-row.flex-no-wrap
                        div
                            .scope
                                p.fragment Receiving the state of the device
                                ul
                                    li.fragment <span class="highlight">polling</span> - compare against previous state
                                    li.fragment <span class="highlight">callbacks</span> - handled by upper SW layer
                            .scope.fragment
                                p Devices
                                ul
                                    li keyboard, touch sensor, camera, Oculus Touch,...
                                    li one-axis controller - single analog state
                                    li two-axis controller - mouse and joystick
                                    li three-axis controller - accelerometer
                            .scope.fragment
                                p Dead zone
                                ul
                                    li area of a control interface that has no input effect (analog joystick)
                            .scope.fragment
                                p Normalization
                                ul
                                    li analog axis are mapped to a Cartesian space, not a circular one
                                    li input must be normalized
                        div.width-30p.self-end
                            div.text-center
                                figure.fragment
                                    img.height-350(src=imgAssets+'normalization.svg')
                                    p Normalized input

            - var imgAssets = '../assets/engines_memory/';
            +mchapter('Engines: Memory', imgAssets+'chapter_engines_memory.svg')
            +frameInbox('Memory Manager')
                .important-orange
                    div
                        ul
                            li.fragment.fade-up default managers are not suitable for games (i.e. malloc function)
                            li.fragment.fade-up game engines usually have their own allocators
                    .scope.mt-40.fragment.fade-up
                        p Custom allocators
                        ul
                            li.fragment.fade-up stack allocator
                            li.fragment.fade-up pool allocator
                            li.fragment.fade-up heap allocator
                            li.fragment.fade-up bucket allocator
                    .bottom-20.right-50.fragment.fade-up
                        img.height-500(src=imgAssets+'fragmentation.svg')
            +frameInbox('Pool allocator')
                .important-orange
                    div
                        ul
                            li allocates lots of small blocks of memory, each of the same size
                            li.upside.fragment.fade-up doesn't suffer from memory fragmentation
                            li.downside.fragment.fade-up entities have to be of the same size
                    .center.mt-100
                        img.height-400(src=imgAssets+'pool_allocator.svg')
            +frameInboxMid('Other allocators')
                .important-orange
                    div
                        .scope.fragment.fade-up
                            p Bucket allocator
                            ul
                                li several pool allocators for objects of various sizes
                                li.upside great solution for demanding games
                                li.downside difficult to manage
                        .scope.fragment.fade-up
                            p Heap allocator
                            ul
                                li more or less the same as heaps in virtual machines
                                li.upside very flexible
                                li.downside requires garbage collector
            +frameInbox('Data loading')
                .important-orange
                    .scope.fragment.fade-up 
                        p Level loading
                        ul
                            li used in <span class="highlight-2">Tomb Raider, Doom, Quake,...</span>
                            li requires a loading screen
                            li only one game chunk is loaded at a time
                            li appropriate for games with levels, separated scenes or star topology
                    .scope.fragment.fade-up
                        p Air locks
                        ul
                            li used in <span class="highlight-2">Half-Life, Inside, Portal (partially)</span>
                            li air lock is a small scene (room, hall)
                            li when the player enters the area from which can't see the previous one, next scene is loaded
                    .scope.fragment.fade-up
                        p World streams
                        ul
                            li used in <span class="highlight-2">GTA, WoW, Arma, Spiderman</span>
                            li the world is divided into regions
                            li the engine unloads chunks too far away and loads new chunks the player is heading to
                            li uses <span class="highlight">LOD system</span> - chunks are loaded at variable granularity

            - var imgAssets = '../assets/engines_scripting/';
            +mchapter('Engines: Scripting Engine', imgAssets+'chapter_engines_scripting.svg')
            +frameInbox('Scripting architectures')
                div.leading-2xl.important-orange
                    .scope.fragment
                        p Scripted callbacks
                        ul
                            li certain functions are customizable via scripts
                            li a game object can respond to some relevant occurrence within the game world (in-game scripts)
                    .scope.fragment
                        p Scripted components
                        ul
                            li new components/objects/properties can be constructed entirely in a script
                            li firstly used in <span class="highlight-2">Dungeon Siege</span>
                    .scope.fragment
                        p Script-driven game
                        ul
                            li script is running the game and the core systems are written in the engine
                            li used in Unreal, Unity, Godot, GameMaker,...
                    .scope.fragment
                        p Script-driven engine
                        ul
                            li script drives the entire engine (PixiJS, ThreeJS, p5.js, BabylonJS)
            +frameInbox('Game Engine Scripting API')
                .important-orange
                    div
                        ul
                            li.fragment the engine needs to communicate with the script - provided by <span class="highlight">bridging</span>
                            ul
                                li.fragment JNI (Java and C++)
                                li.fragment P/Invoke (.NET and C++)
                                li.fragment Dukbind (Duktape JS and C++)
                            li.fragment bridge is a performance bottleneck, especially for per-frame calls
                            li.fragment more scripting languages = more bridges to maintain
                            li.mt-40.fragment
                                span.highlight Marshalling
                                ul
                                    li transforming memory representation of an object between two domains (different programming languages)
                            li.mt-40.fragment
                                span.highlight Semantic gap
                                ul
                                    li descriptive difference of an object in various representations (e.g. relational database vs object-oriented structure)

            +summary_lecture02()


            - var imgAssets = '../assets/assets_intro/';
            +mchapter('Assets: Introduction to Assets', imgAssets+'chapter_assets_intro.svg')
            +mcontainer('What are assets?').important-orange
                +frameShard.width-860.top-3p.fragment.fade-up
                    p Everything that is specific to a game (and not to an engine).
                +frameShard.width-860.top-6p.left-20p.fragment.fade-up
                    p Any piece of data which is in a format that can be used by the game engine.
                +frameShard.width-860.top-9p.left-40p.fragment.fade-up
                    p All visual elements that are presented to the user and protected by copyright.
        
            - var imgAssets = '../assets/assets_management/';
            +mchapter('Assets: Assets management', imgAssets+'chapter_assets_management.svg')
            +frameInbox('Resource Manager')
                .important-orange.leading-xl
                    .scope.fragment.fade-up
                        .highlight Provides access to all resources (~assets)
                        ul
                            li meshes, materials, shaders, animations, textures, clips, levels
                            li many assets are not used in their original format
                            li <span class="highlight-2">Resource Cache</span> - used for faster access
                    .scope.fragment.fade-up
                        .highlight Manages lifetime of each resource
                        ul
                            li most managers maintain some kind of registry
                    .scope.fragment.fade-up
                        .highlight Ensures that only one copy of each resource exists in memory
                        ul
                            li resource GUID - usually path to the file, guaranteed to be unique
                    .scope.fragment.fade-up
                        .highlight Loads required resources and unloads those no longer needed
                        ul
                            li loading is simpler than unloading
                    .scope.fragment.fade-up
                        .highlight Handles streaming
                        ul
                            li in case of open worlds

            - var imgAssets = '../assets/assets_multimedia/';
            +mchapter('Assets: Multimedia assets', imgAssets+'chapter_assets_multimedia.svg')
            +frameInbox('Image Formats')
                .important-orange
                    .flex-cols-2
                        div
                            .scope.fragment(data-fragment-index="1")
                                p JPEG
                                ul
                                    li Joint Photographic Experts Group
                                    li used for storing digital photography
                                    li doesn't support alpha channel
                            .scope.fragment(data-fragment-index="2")
                                p PNG
                                ul
                                    li Portable Network Graphics
                                    li good results for simple images (not real pictures)
                            .scope.fragment(data-fragment-index="3")
                                p TGA
                                ul
                                    li Truevision TGA
                                    li favorite format for textures
                            .scope.fragment(data-fragment-index="4")
                                p SVG
                                ul
                                    li Scalable Vector Graphics
                                    li format for vector images
                        div.text-center
                            div.fragment(data-fragment-index="1")
                                img.height-300.mt-20(src=imgAssets+'assets_images_jpg.jpg')
                            div.fragment(data-fragment-index="2")
                                img.height-300.mt-20(src=imgAssets+'assets_images_png.png')
                            div.fragment(data-fragment-index="4")
                                img.height-100.mt-20(src=imgAssets+'assets_images_svg.svg')
            +frameInbox('Videos and Cutscenes')
                .important-orange
                    .flex-cols-2
                        div
                            ul
                                li.fragment <span class="highlight font-bold">Cutscene</span>
                                    ul
                                        li.fragment one of the most progressive properties of a game
                                        li.fragment <span class="highlight-2">a) fully progressive</span> - video, in-game cutscene
                                        li.fragment <span class="highlight-2">b) partially progressive</span> - i.e. custom skin of the avatar in the scene
                                        li.fragment <span class="highlight-2">c) partially emergent</span> - the player can walk around but can't control the scene
                                        li.fragment <span class="highlight-2">d) fully emergent</span> - generated cutscene
                                li.mt-30.fragment <span class="highlight">1980's</span> - in-game cutscenes
                                li.fragment <span class="highlight">1990's</span> - pre-rendered video cutscenes
                                li.fragment <span class="highlight">2000's</span> - in-game cutscenes
                                li.fragment <span class="highlight">2010's</span> - pre-rendered video cutscenes ¯\_(ツ)_/¯
                        div.text-center
                            img.height-380(src=imgAssets+'cutscene_w3.jpg')
                            img.height-380(src=imgAssets+'cutscene_hellblade.jpg')
            +frameInbox('Textures')
                .important-orange
                    .flex-cols-2
                        div
                            ul
                                li.fragment(data-fragment-index="1") pieces of bitmap that are applied to an object
                                li.highlight-2.fragment(data-fragment-index="2") textures are ultimately converted to formats that are specific to platform and graphic API
                            .scope.fragment(data-fragment-index="3")
                                p Types
                                ul
                                    li.fragment(data-fragment-index="4") diffuse texture
                                    li.fragment(data-fragment-index="5") displacement texture
                                    li.fragment(data-fragment-index="6") normal texture
                                    li.fragment(data-fragment-index="7") volumetric texture
                                    li.fragment(data-fragment-index="8") tileable texture
                                    li.fragment(data-fragment-index="9") sprite atlas
                            .scope.fragment(data-fragment-index="10")
                                p Formats
                                ul
                                    li Desktop: BC6H, BC7, DXT1, DXT5
                                    li iOS: ATSC, PVRTC
                                    li Android: ASTC
                        .grid.grid-cols-2
                            div
                                figure.fragment(data-fragment-index="4")
                                    img.height-210(src=imgAssets+'texture_color.jpg')
                                    p Diffuse
                                figure.fragment(data-fragment-index="5")
                                    img.height-210(src=imgAssets+'texture_displacement.jpg')
                                    p Displacement
                                figure.fragment(data-fragment-index="6")
                                    img.height-210(src=imgAssets+'texture_normal.jpg')
                                    p Normal
                            div
                                figure.fragment(data-fragment-index="7")
                                    img.height-210(src=imgAssets+'texture_volumetric.jpg')
                                    p Volumetric
                                figure.fragment(data-fragment-index="8")
                                    img.height-210(src=imgAssets+'texture_tileable.jpg')
                                    p Tileable
                                figure.fragment(data-fragment-index="9")
                                    img.height-210(src=imgAssets+'spriteanim.gif')
                                    p Sprite atlas
            +frameInbox('Sprites')
                .important-orange
                    .leading-md
                        .scope.fragment.fade-up
                            p Sprite
                            ul
                                li a single graphic image that is incorporated into a scene
                                li allows to create large scenes as you can manipulate each sprite separately
                        .scope.fragment.fade-up
                            p Spritesheet
                            ul
                                li a set of corresponding sprites
                        .scope.fragment.fade-up
                            p Sprite atlas
                            ul
                                li a single texture image containing a list of spritesheets
                    .text-center.mt-30.fragment.fade-up
                        img.height-370(src=imgAssets+'prince2.png')

            - var imgAssets = '../assets/assets_generic/';

            +summary_lecture03()


            - var imgAssets = '../assets/components_model/';
            +mchapter('Components: Game Model', imgAssets+'chapter_components_model.svg')
            +mcontainer('What is a Game Model').important-orange
                +frameShard.width-70px.height-20p.top-280.center.z-index-100.fragment
                    p <span class="highlight">Game model</span> is a <span class="highlight-2">model</span> of a <span class="highlight-2">domain</span> in which the simulated world takes place.

            - var imgAssets = '../assets/components_components/';
            +mchapter('Components: Component-oriented architecture', imgAssets+'chapter_components_components.svg')
            +frameInbox('Component')
                .important-red
                    ul
                        li.fragment(data-fragment-index="1") a unit of composition with specified interfaces and explicit context dependencies
                        li.fragment(data-fragment-index="2") components are <span class="highlight">plug-and-play objects</span>
                        li.fragment(data-fragment-index="3") prefers composition over inheritance
                        li.fragment(data-fragment-index="4") behavior of an entity is determined by the aggregation of its components
                        li.fragment(data-fragment-index="5") <span class="highlight">Dungeon Siege (2002)</span> - one of the first games featuring component-based systems
                    .space-2xl
                    .text-center
                        img.height-250(src=imgAssets+'component.svg')
            +frameInbox('ECS Pattern')
                .important-red
                    ul
                        li.fragment.highlight Entity-Component-System
                        li.fragment common pattern for component-oriented libraries and engines
                        li.fragment game object is just a container for data and logic
                        li.fragment components are attached to their game objects
                        li.fragment can be easily integrated into <span class="highlight">scene graph</span>
                    .text-center
                        img.height-500.mt-15(src=imgAssets+'ecs.svg')
            +frameInbox('Terms')
                .important-orange
                    .scope.fragment
                        p Entity
                        ul
                            li a single entity/game object, usually incorporated into a scene graph
                    .scope.fragment
                        p Attribute
                        ul
                            li data unit attached to an entity
                    .scope.fragment
                        p Property
                        ul
                            li data unit attached to a component
                    .scope.fragment
                        p Component
                        ul
                            li instantiable unit that defines <span class="highlight-2">simple</span> functional behavior
                    .scope.fragment
                        p System
                        ul
                            li a superior component responsible for a bigger scope (HealthSystem, GameManager, AudioSystem)
                    +tipKeen('The naming varies. Some engines use behaviours for components, components for systems, property for attributes etc.').bottom-0.right-30p

            - var imgAssets = '../assets/components_messaging/';
            +mchapter('Components: Messaging', imgAssets+'chapter_components_messaging.svg')
            +frameInbox('Messaging possibilities')
                .important-orange
                    .scope.fragment
                        p By modifying the container object's state
                        ul
                            li e.g. shared state machine
                            li indirect communication
                            li difficult to debug
                    .scope.fragment
                        p By direct calls
                        ul
                            li OOP way
                            li fast, but increases coupling
                            li we need to know what to call
                            li e.g. calling a global component that is always present
                    .scope.fragment
                        p By using a message broker
                        ul
                            li events and commands
                            li each component can declare interest in relevant messages
                            li slower than the direct call
                            li e.g. listening to GAME_OVER event and stopping the game
                    .top-160.right-150
                        img.width-700(src=imgAssets+'messaging.svg')
            +frameInbox('Message Broker')
                .important-red
                    ul
                        li.fragment components should be notified of any state change that is relevant
                        li.fragment can be used for returning values (danger of <span class="highlight">feedback deadlock</span>)
                        li.fragment a handler can be implemented inside components - <span class="highlight code">OnMessage()</span> function 
                        li.fragment processing can be instant or delayed/scheduled
                        li.fragment <span class="highlight">Event</span> - a message informing that something happened
                        li.fragment <span class="highlight">Command</span> - a message instructing that something should happen
                    .space-md
                    .text-center
                        img.height-300(src=imgAssets+'diag_message.svg')
            +frameInbox('Message Types')
                .important-orange
                    .scope.fragment
                        p Unicast
                        ul
                            li a component sends a message to another component
                            li in most cases, this can be handled by a direct call
                            li example: pause the game
                    .scope.fragment
                        p Multicast
                        ul
                            li a) component sends a message to subscribers
                            li b) component sends a message to all objects that meet specific criteria
                            li example: notify all nearby units that the player has entered the area
                            li example: collision trigger - notify all subscribers 
                    .scope.fragment
                        p Broadcast
                        ul
                            li rarely used, usually for global messages
                            li example: level completed, game over
                    .bottom-0.right-20
                        img.height-680(src=imgAssets+'messaging_types.svg')
        
            +summary_lecture04()
            

            - var imgAssets = '../assets/patterns_action/';
            +mchapter('Patterns: Action Patterns', imgAssets+'chapter_patterns_action.svg')
            +frameInbox('Chain')
                .important-orange
                    ul
                        li.fragment <span class="highlight">Process</span> - something that requires more than one frame to finish
                            ul
                                li.fragment basically anything that involves animations, mini cut-scenes, delayed actions, sounds
                        li.fragment <span class="highlight">Chain</span> - a set of commands, events and processes that need to be evaluated in a given order
                        li.mt-20.fragment 
                            p.highlight implementation
                            ul
                                li.fragment <span class="highlight-2">callbacks</span> - basically in every language, very bad robustness
                                li.fragment <span class="highlight-2">listener chaining</span> - any language with closures (Java, JavaScript, C#,..)
                                li.fragment <span class="highlight-2">iterator blocks</span> - C#
                                li.fragment <span class="highlight-2">promises and generators</span> - JavaScript
                                li.fragment <span class="highlight-2">coroutines</span> - Kotlin, Ruby, Lua,...
                    .bottom-0.right-0.fragment
                        img.height-400(src=imgAssets+'chain_pokemon.gif')
                    .bottom-40.left-40.fragment
                        img.height-230(src=imgAssets+'chain.svg')
            +frameInbox('Responsibility ownership')
                .important-orange
                    ul
                        li.fragment(data-fragment-index="1") determines which component should be responsible for given scope/action/decision
                        li.fragment(data-fragment-index="2") there is no bulletproof recipe, yet it should be unified
                        li.fragment(data-fragment-index="3") if the scope affects <span class="highlight">only one entity</span>, it should be a component attached to that entity
                            ul
                                li.fragment(data-fragment-index="4") <span class="highlight-2">example:</span> a worker that goes to the forest for some wood
                        li.fragment(data-fragment-index="5") if the scope affects <span class="highlight">more entities</span>, it's often a component/system attached either to an abstract entity up the scene graph (e.g. the root object)
                            ul
                                li.fragment(data-fragment-index="6") <span class="highlight-2">example:</span> battle formation controller, duel controller (who wins, who loses)
                    .flex-cols-2.mt-15
                        figure.fragment(data-fragment-index="4")
                            img.height-330(src=imgAssets+'ownership_cossacks3.jpg')
                            p Individual units
                        figure.fragment(data-fragment-index="6")
                            img.height-330(src=imgAssets+'ownership_group_cossacks3.jpg')
                            p Battle formation
            - var imgAssets = '../assets/patterns_optimizing/';
            +mchapter('Patterns: Optimizing Patterns', imgAssets+'chapter_patterns_optimizing.svg')
            +frameInbox('Flyweight')
                .important-orange
                    ul
                        li.fragment an object keeps shared data to support large number of fine-grained objects
                        li.fragment e.g. instanced rendering, geometry hashing, particle systems
                        li.fragment here we move a position and a tile index (Sprite) into an array
                    .text-center.mt-20.fragment
                        img.height-610(src=imgAssets+'flyweight.svg')

            - var imgAssets = '../assets/patterns_structural/';
            +mchapter('Patterns: Structural Patterns', imgAssets+'chapter_patterns_structural.svg')
            +frameInbox('Selector')
                .important-orange
                    ul
                        li.fragment a function that returns a value
                        li.fragment centralizes the knowledge of how to find an entity/attribute/component
                        li.upside.fragment can be used by components to access dynamic data
                        li.upside.fragment can form a hierarchy from other selectors
                    .code.mt-20.fragment
                        include ../assets/patterns_structural/snippets_generated/selector.html

            - var imgAssets = '../assets/patterns_state/';
            +mchapter('Patterns: State Patterns', imgAssets+'chapter_patterns_state.svg')
            +frameInbox('Flag')
                .important-orange
                    ul
                        li.fragment <span class="highlight">bit array</span> that stores binary properties of game objects
                        li.fragment may be used for queries (e.g. find all MOVABLE objects)
                        li.fragment similar to a state machine but the use-case is different
                        li.fragment if we maintain all flags within one single structure, we can search very fast
                    .bottom-70.left-150.fragment
                        img.height-250(src=imgAssets+'flag_01.svg')
                    .bottom-50.right-300.fragment
                        img.height-150(src=imgAssets+'mage.png')
            +frameInbox('Numeric state')
                .important-orange
                    ul
                        li.fragment the most basic state of an entity
                        li.fragment allows us to set conditions upon which a transition to other states is possible
                    .code.mt-20.fragment
                        include ../assets/patterns_state/snippets_generated/numeric_state.html
                    .bottom-0.right-0.fragment
                        img.height-400(src=imgAssets+'jump.gif')

            - var imgAssets = '../assets/patterns_creational/';
            +mchapter('Patterns: Creational Patterns', imgAssets+'chapter_patterns_creational.svg')
            +frameInbox('Builder')
                .important-orange
                    ul
                        li.fragment a template that keeps attributes from which it can build new objects
                        li.fragment each method returns back the builder itself, so it can be chained
                    .code.mt-20.text-xs.fragment
                        include ../assets/patterns_creational/snippets_generated/builder.html
                .right-0.bottom-150.fragment
                    img.height-420(src=imgAssets+'builder.svg')
            +frameInbox('Prototype')
                .important-orange
                    ul
                        li.fragment <span class="highlight">Builder</span> builds new objects from scratch, <span class="highlight">Prototype</span> creates new objects by copying their attributes 
                        li.fragment in some implementations, the prototype is linked to its objects - if we change the prototype, it will affect all derived entities
                        li.fragment e.g. templates in Godot, linked prefabs in Unity and Unreal engine
                    .flex-cols-2.items-end.mt-20.fragment
                        img.height-420.mb-60(src=imgAssets+'prototype.svg')
                        figure
                            img.height-500(src=imgAssets+'unity_prefab.gif')
                            p Prefabs in Unity
            +frameInbox('Factory')
                .important-orange
                    ul
                        li.fragment <span class="highlight">Builder</span> assembles an object, <span class="highlight">factory</span> manages the assembling
                        li.fragment Factory creates an object according to the parameters but with respect to the context
                    .code.mt-20.text-sm.fragment
                        include ../assets/patterns_creational/snippets_generated/factory.html

            +summary_lecture05()

            - var imgAssets = '../assets/audio_digital_sound/';
            +mchapter('Audio: Digital Sound', imgAssets+'chapter_digital_sound.svg')
            +frameInbox('PCM')
                .important-orange
                    ul.leading-lg
                        li.fragment.fade-up pulse-code modulation, a method used to digitally represent sampled analog signals
                        li.fragment.fade-up <span class="highlight">sample</span> - fundamental unit, representing the amplitude of an audio signal in time
                        li.fragment.fade-up <span class="highlight">bit depth</span> - each bit of resolution is equal to 6dB of dynamic range
                        li.fragment.fade-up <span class="highlight">sample rate</span> - number of samples per second: 8 kHz, 22.05 kHz, 44.1 kHz, 48 kHz
                        li.fragment.fade-up <span class="highlight">frequency</span> - a measure of the number of pulses in a given space of time
                        li.fragment.fade-up <span class="highlight">frame</span> - collection of samples, one for each output (e.g. 2 for stereo)
                        li.fragment.fade-up <span class="highlight">buffer</span> - collection of frames in memory, typically 64-4096 samples per buffer
                            ul.fragment.fade-up
                                li.highlight-2 the greater the buffer, the greater the latency, but less strain being placed on the cpu
                    .text-center.mt-20.fragment.fade-up
                        img.height-400(src=imgAssets+'digital_sound.svg')
            
            - var imgAssets = '../assets/audio_synth/';
            +mchapter('Audio: Sound synthesizing', imgAssets+'chapter_synth.svg')
            +frameInbox('Sound generators')
                .important-orange
                    ul
                        li.fragment <span class="highlight">generator</span> - oscillator that can make a tone, either independently or by pairing with another generator
                            ul
                                li.fragment synth music is a combination of generated tones, effects, filters, and recorded sound samples
                        li.fragment <span class="highlight">main synthesis types</span>: additive, subtractive, FM, wavetable
                    .text-center.mt-20.fragment
                        img.height-600(src=imgAssets+'waves.svg')

            - var imgAssets = '../assets/audio_music/';
            +mchapter('Audio: Music in games', imgAssets+'chapter_audio_gamemusic.svg')
            +frameInbox('Music in games')
                .important-orange
                    .leading-lg
                        .scope.fragment
                            p Assets
                            ul
                                li.fragment <span class="highlight-2">sound cues</span> - collection of audio clips with metadata
                                li.fragment <span class="highlight-2">sound banks</span> - package of sound clips and cues (e.g. all voices of one person)
                        .scope.fragment
                            p Asset categories
                            ul
                                li.fragment <span class="highlight-2">diegetic</span> - visible (character voices, sounds of objects, footsteps)
                                li.fragment <span class="highlight-2">non-diegetic sound</span> - invisible (sountrack, narrator)
                                li.fragment <span class="highlight-2">background music</span> - ambient music (e.g. river)
                                li.fragment <span class="highlight-2">score</span> - soundtrack, is clearly recognizable
                                li.fragment <span class="highlight-2">interface music</span> - button press
                                li.fragment <span class="highlight-2">custom music</span> (e.g. GTA radio)
                                li.fragment <span class="highlight-2">alert</span> - music triggered by an event
                        .scope.fragment
                            p Dynamics
                            ul
                                li.fragment <span class="highlight-2">linear audio</span> - only reflects major changes (e.g. finished level)
                                li.fragment <span class="highlight-2">dynamic audio</span> - changes in response to changes in the environment or gameplay
                                li.fragment <span class="highlight-2">adaptive audio</span> - responses to the gameplay, adapts itself based on game attributes
            +frameInbox('Dynamic music')
                .important-orange
                    .scope.fragment
                        p Features
                        ul
                            li.fragment <span class="highlight">looping</span> - going around and around
                                div
                                    img.mt-20.width-800(src=imgAssets+'features_looping.svg')
                            li.fragment <span class="highlight">branching</span> - conditional music
                                div
                                    img.mt-20.width-600(src=imgAssets+'features_branching.svg')
                            li.fragment <span class="highlight">layering</span> - some pieces can be muted on and off and re-combined
                                div
                                    img.mt-20.width-900(src=imgAssets+'features_layering.svg')
                            li.fragment <span class="highlight">transitions</span> - moving smoothly from one cue to another
                                div
                                    img.mt-20.width-800(src=imgAssets+'features_transitions.svg')

            - var imgAssets = '../assets/audio_sounds/';
            +mchapter('Audio: Sounds in games', imgAssets+'chapter_audio_gamesound.svg')
            +frameInbox('3D Sound')
                .important-orange
                    .scope.fragment
                        p Attenuation
                        ul
                            li the further the sound, the quieter it is
                        .right-50.top-100
                            img.height-260(src=imgAssets+'3dsound_attenuation.svg')
                    .space-md
                    .scope.mt-100.fragment
                        p Occlusion
                        ul
                            li how sound is occluded by solid objects, losing its high frequency
                        .right-50.top-370
                            img.height-260(src=imgAssets+'3dsound_occlusion.svg')
                    .space-md
                    .scope.mt-100.fragment
                        p Obstruction
                        ul
                            li when the direct path to a sound is muffled but not enclosed
                            li creates delays
                        .right-50.top-640
                            img.height-260(src=imgAssets+'3dsound_obstruction.svg')

            +summary_lecture06()


            - var imgAssets = '../assets/space_randomness/';
            +mchapter('Audio: Randomness', imgAssets+'chapter_random.svg')
            +frameInbox('Random Functions Distribution')
                .important-orange
                    .scope.fragment(data-fragment-index='1')
                        p Uniform distribution
                        ul
                            li.fragment(data-fragment-index='2') most common distribution of random generators
                            li.fragment(data-fragment-index='3') <span class="highlight-2">applications:</span> noise, shuffling, dice
                    .scope.fragment(data-fragment-index='4')
                        p Gaussian (normal) distribution
                        ul
                            li.fragment(data-fragment-index='5') more common in games - every characteristic has some kind of average, with individuals varying with a normal distribution
                            li.fragment(data-fragment-index='6') can be calculated from a uniform generator via transformation (Box-muller algorithm)
                            li.fragment(data-fragment-index='7') <span class="highlight-2">applications:</span> height of trees, aiming for projectiles, average speed, physical reaction time, reload rate, refresh healing rate, critical hit
                    .flex-cols-2
                        figure.fragment(data-fragment-index='1')
                            img.height-250(src=imgAssets+'distribution_uniform.svg')
                            p Uniform distribution
                        figure.fragment(data-fragment-index='4')
                            img.height-250(src=imgAssets+'distribution_normal.svg')
                            p Gaussian distribution
            +frameInbox('Terms')
                .important-orange
                    .leading-md
                        .scope.fragment
                            p Seed
                            ul
                                li.fragment a hash that initializes random generators
                                li.fragment a good source of entropy is <span class="highlight-2">user input</span> or <span class="highlight-2">time</span>
                        .scope.fragment
                            p Loot
                            ul
                                li.fragment items obtained over the gameplay (money, spells, equipment, weapons,...)
                        .scope.fragment
                            p Spinning
                            ul
                                li.fragment calling the random function on a time-frame basis without using the result
                                li.fragment advances the game to a difficult-to-predict place
                        .scope.fragment
                            p Rarity Slotting
                            ul
                                li.fragment a method of standardization to determine rates (common, rare, epic, legendary)
                                li.fragment can be defined as a rarity table, calculated via weighted sum
                        .scope.fragment
                            p Random encounter
                            ul
                                li.fragment popular mechanics of RPG games (Final Fantasy, Pokémon, Golden Sun)
                                li.fragment the game suddenly shifts to battle mode, forcing the player to fight
                                li.fragment after winning the battle, the player receives a reward (skill upgrade, items, money)

            - var imgAssets = '../assets/space_procedural/';
            +mchapter('Space: Procedural generation', imgAssets+'chapter_procedural.svg')
            +frameInbox('Noise')
                .important-orange
                    ul
                        li.fragment Randomness is used to vary characteristics, noise is used to vary them over time or in space
                        li.mt-40.fragment <span class="highlight">Noise functions</span>
                            ul
                                li.fragment <span class="highlight-2">Lattice-based</span>
                                    ul
                                        li.fragment Perlin noise, Simplex noise, Wavelet noise, Value noise
                                li.fragment <span class="highlight-2">Point-based</span>
                                    ul
                                        li.fragment Worley noise (Voronoi/Cellular)
                    .space-md
                    .flex-cols-3.fragment
                        figure
                            img.height-320(src=imgAssets+'noise_perlin.jpg')
                            p Perlin Noise
                        figure
                            img.height-320(src=imgAssets+'noise_simplex.jpg')
                            p Simplex Noise
                        figure
                            img.height-320(src=imgAssets+'noise_worley.jpg')
                            p Worley Noise

            - var imgAssets = '../assets/space_geometry/';
            +mchapter('Space: Geometry', imgAssets+'chapter_geometry.svg')
            +frameInbox('Points and Vectors')
                .important-orange
                    ul
                        li.fragment <span class="highlight">Vector</span> - a quantity that has both a magnitude and a direction
                        li.fragment vector can be used to represent a point, provided that we fix the tail of the vector to the origin of the coordinate system
                    .space-lg
                    .scope.fragment
                        p Addition and subtraction
                        ul
                            li vector + vector = vector
                            li vector - vector = vector
                            li point + vector = point
                            li point - point = vector
                            li point + point = <span class="highlight">undefined</span>
                        .bottom-220.right-180
                            figure
                                img.height-250(src=imgAssets+'add_subtract.svg')
                                p Vector addition and subtraction
            +frameInbox('Points and Vectors')
                .important-orange
                    .scope.fragment
                        p Magnitude
                        ul
                            li scalar representing the length of the vector
                            li 
                                include ../assets/space_geometry/equations_generated/vectors_01.svg
                        .top-10.right-50
                            figure
                                img.height-270(src=imgAssets+'magnitude.svg')
                                p Magnitude of a vector
                    .scope.mt-5.fragment
                        p Normalization
                        ul
                            li a unit vector is a vector with a magnitude of one: 
                                include ../assets/space_geometry/equations_generated/vectors_02.svg
                    .scope.mt-5.fragment
                        p Normal vector
                        ul
                            li vector is normal to a surface if it is perpendicular to it
                    .scope.mt-5.fragment
                        p Dot product
                        ul
                            li
                                include ../assets/space_geometry/equations_generated/vectors_03.svg
                            li
                                include ../assets/space_geometry/equations_generated/vectors_04.svg
                        .bottom-10.right-20
                            figure
                                img.height-300(src=imgAssets+'dot_product.svg')
                                p Dot Product
                    .scope.mt-5.fragment
                        p Cross product
                        ul
                            li yields another vector that is perpendicular to two vectors
                            li
                                include ../assets/space_geometry/equations_generated/vectors_05.svg
            +frameInbox('Rotation in 3D space')
                .important-orange.text-center
                    img.height-750(src=imgAssets+'rotation.svg')
            +frameInbox('Rotational representations')
                .important-orange
                    .scope.fragment
                        p Euler angles
                        ul
                            li.fragment Pitch, Yaw, Roll
                            li.upside.fragment simple, small size (3 floats), intuitive
                            li.downside.fragment the order in which the rotations are performed matters
                            li.downside.fragment gimbal lock issue - when a 90-degree rotation causes one axis to collapse onto another
                    .scope.mt-80.fragment
                        p Axis + angle
                        ul
                            li.fragment axis of rotation plus a scalar for the angle of rotation 
                                include ../assets/space_geometry/equations_generated/rot_representations.svg
                            li.upside.fragment intuitive and compact
                            li.downside.fragment rotations cannot be easily interpolated
                            li.downside.fragment rotations cannot be applied to vectors directly
            +frameInbox('Rotational representations')
                .important-orange
                    .scope.fragment
                        p Quaternions
                        .bottom-20.right-20
                            img.height-550(src=imgAssets+'quaternions.svg')
                        ul
                            li.fragment similar to axis + angle, but with an algebraic twist
                            li.fragment
                                include ../assets/space_geometry/equations_generated/quaternions_01.svg
                            li.fragment alternative form: 
                                include ../assets/space_geometry/equations_generated/quaternions_02.svg
                            li.fragment unit-length: 
                                include ../assets/space_geometry/equations_generated/quaternions_03.svg
                        .space-md
                        ul
                            li.fragment a unit quaternion can be visualised as a 3D vector + scalar
                            li.fragment
                                include ../assets/space_geometry/equations_generated/quaternions_04.svg
                            li.fragment
                                include ../assets/space_geometry/equations_generated/quaternions_05.svg
                    ul.mt-20
                        li.upside.fragment permits rotations to be concatenated and applied directly
                        li.upside.fragment permits rotations to be easily interpolated
                        li.downside.fragment can perform only one full rotation between keyframes
                    +tipKeen('Use Euler angles for fast rotation around one axis and quaternions for complex rotations around all axes').bottom-0.left-0

            - var imgAssets = '../assets/space_geometric_hashing/';
            +mchapter('Space: Geometric hashing', imgAssets+'chapter_spatial.svg')
            +frameInbox('Spatial partitioning')
                .important-orange
                    .scope.fragment
                        p Bounding volume
                        ul
                            li.fragment groups objects or their parts together based on their positions and sizes
                            li.fragment if the object moves, so will the hierarchy
                            li.fragment used for physics, shape analysis, precise collision detection
                    .scope.fragment
                        p Spatial data structure
                        ul
                            li.fragment a structure that stores objects by their position
                            li.fragment is locked to the world
                            li.fragment used for range queries, neighborhood searching, rough collision detection
                            li.highlight-2.fragment the more objects we have, the more benefits we get
                    .scope.fragment
                        p Implementations
                        ul
                            li.fragment <span class="highlight-2">BSP</span> - binary-space partitioning
                            li.fragment <span class="highlight-2">Quad-tree</span> - for 2D and semi-3D space
                            li.fragment <span class="highlight-2">Oct-tree</span> - for 3D space
                            li.fragment <span class="highlight-2">Grid</span> - a square grid
                        .bottom-50.right-50
                            figure
                                img.height-300(src=imgAssets+'oct_tree.svg')
                                p Oct-tree
            +frameInbox('Binary Space Partitioning')
                .important-orange
                    ul
                        li.fragment(data-fragment-index='1') algorithm that decomposes a <span class="highlight">polygon-soup</span> into a tree that contains <span class="highlight">convex sets</span>
                        li.fragment(data-fragment-index='2') first used in Doom to solve difficult rendering of circles around pillars in level 2
                        li.upside.fragment(data-fragment-index='3') very good for rendering, ray-casting and collision detection in complex <span class="highlight">indoor</span> environments
                        li.downside.fragment(data-fragment-index='4') works only in static environments and requires a complex preprocessing stage
                    .space-md
                    .space-md
                    .flex-cols-2
                        img.height-300.fragment(data-fragment-index='1', src=imgAssets+'bsp.svg')
                        img.height-300.fragment(data-fragment-index='5', src=imgAssets+'bsp_example.svg')
            +frameInbox('Quad-tree')
                .important-orange
                    ul
                        li.fragment(data-fragment-index='1') hierarchical partition
                        li.fragment(data-fragment-index='2') each inner node has 4 children
                        li.fragment(data-fragment-index='3') overlapping solid objects are put into all children they touch
                        li.fragment(data-fragment-index='4') only objects in the same leaf can be in collision
                        li.fragment(data-fragment-index='5') useful for <span class="highlight">outdoor</span> scenes
                        li.fragment(data-fragment-index='6') good for object sparsely spread that do not move too fast
                    .text-center.fragment(data-fragment-index='1')
                        img.height-460(src=imgAssets+'quad_tree.svg')
            +frameInbox('Quad-tree and geometric hashing')
                .important-orange
                    .text-center.mt-80
                        img.height-620(src=imgAssets+'quad_tree_hashing.svg')
            +frameInbox('Grid')
                .important-orange
                    ul
                        li.fragment(data-fragment-index='1') implemented as an 1D/2D/3D array or a hash-table
                        li.fragment(data-fragment-index='2') each cell has a list of units that are inside
                        li.fragment(data-fragment-index='3') if a unit crosses the boundary of the cell, we need to move it to the other list
                        li.highlight.fragment(data-fragment-index='4') good for a large amount of fast objects that are uniformly distributed
                        li.upside.fragment(data-fragment-index='5') very fast to locate an object - in sharp contrast with recursing down a quad-tree
                        li.downside.fragment(data-fragment-index='6') takes up more memory, granularity is static
                    .text-center.mt-20.fragment(data-fragment-index='1')
                        img.height-400(src=imgAssets+'grid.svg')
        
            - var imgAssets = '../assets/space_navigation/';
            +mchapter('Space: Navigation', imgAssets+'chapter_navigation.svg')
            +frameInbox('Navigation graph')
                .important-orange
                    .scope.fragment(data-fragment-index='1')
                        p Grid-based
                        ul
                            li.fragment(data-fragment-index='2') created by superimposing a grid over a game environment
                            li.fragment(data-fragment-index='3') <span class="highlight-2">traversability flag</span> indicates whether the cell is traversable or not
                            li.fragment(data-fragment-index='4') connection geometries: <span class="highlight-2">tile, octile, hex</span>
                            li.fragment(data-fragment-index='5') reflecting renvironmental changes = recalculation of the traversability flag
                    .text-center.mt-30.fragment(data-fragment-index='4')
                        img.height-190(src=imgAssets+'nav_grid.svg')
                    .text-center.mt-10.fragment(data-fragment-index='3')
                        img.height-280(src=imgAssets+'nav_grid_2.svg')
            +frameInbox('Pathfinding algorithms')
                .important-orange
                    .scope.fragment
                        p Uniformed graph searches
                        ul.leading-sm
                            li.fragment searches a graph without regard to any associated edge cost
                            li.fragment <span class="highlight-2">DFS (depth-first search)</span>
                                ul.leading-md
                                    li.fragment searches by moving as deep into the graph as possible
                                    li.fragment doesn't guarantee to find the best path
                            li.fragment <span class="highlight-2">BFS (breadth-first-search)</span>
                                ul.leading-md
                                    li.fragment fans out from the source node, always finds the best path
                    .scope.fragment
                        p Cost-based graph searches
                        ul.leading-sm
                            li.fragment <span class="highlight-2">Dijkstra's Algorithm</span>
                                ul.leading-md
                                    li.fragment explores every node in the graph and finds the shortest path from the start node to every other node in the graph
                                    li.fragment uses <span class="highlight-2">CSF (cost-so-far)</span> metric
                                    li.fragment explores many unnecessary nodes
                            li.fragment <span class="highlight-2">A* (Dijkstra with a Twist)</span>
                                ul.leading-md
                                    li.fragment extension of Dijkstra, invented in 1968
                                    li.fragment main difference: augmentation of the CSF value with a <span class="highlight-2">heuristic value</span>
                    .top-50.right-50
                        img.height-470(src=imgAssets+'pathfinding.png')
            +frameInbox('A*')
                .important-orange
                    ul
                        li.fragment improved Dijkstra by an <span class="highlight-2">estimate of the cost</span> to the target from each node
                        li.fragment Cost 
                            include ../assets/space_navigation/equations_generated/astar_01.svg
                            |, where 
                            include ../assets/space_navigation/equations_generated/astar_02.svg
                            |&nbsp;is the cost-so-far and 
                            include ../assets/space_navigation/equations_generated/astar_03.svg
                            |&nbsp;is the heuristic estimate
                        li.fragment <span class="highlight-2">Heuristics:</span> Euclidean, Manhattan, adaptive, dynamic,...
                            ul
                                li.fragment Manhattan distance will work if almost no obstacles appear
                    .scope.mt-20.fragment
                        p Improvements
                        ul
                            li.fragment preprocess the map, calculate universal paths
                            li.fragment mark tiles which cannot lead anywhere as dead-ends
                            li.fragment limit the search space
                    .text-center.mt-20.fragment
                        img.height-300(src=imgAssets+'astar.svg')
            +frameInbox('Pathfinding algorithms: Comparison')
                .important-orange
                    ul
                        li.fragment breadth-first search ignores the cost
                        li.fragment Dijkstra ignores the topology of the graph
                        li.fragment A* considers both
                    .text-center.mt-20
                        img.height-530(src=imgAssets+'pathfinding_comparison.svg')

            +summary_lecture07()


            - var imgAssets = '../assets/physics_dynamics/';
            +mchapter('Physics: Dynamics', imgAssets+'chapter_dynamics.svg')
            +frameInbox('Motion')
                .important-orange
                    .scope.fragment
                        p Projectile motion
                        ul
                            li.fragment
                                include ../assets/physics_dynamics/equations_generated/motion_01.svg
                            li.fragment
                                include ../assets/physics_dynamics/equations_generated/motion_02.svg
                            li.fragment
                                include ../assets/physics_dynamics/equations_generated/motion_03.svg
                        .top-30.right-150
                            img.width-700(src=imgAssets+'motion_projectile.svg')
                    .space-xl
                    .scope.fragment
                        p Slope motion (no friction)
                        ul
                            li.fragment
                                include ../assets/physics_dynamics/equations_generated/motion_04.svg
                            li.fragment
                                include ../assets/physics_dynamics/equations_generated/motion_05.svg
                            li.fragment
                                include ../assets/physics_dynamics/equations_generated/motion_06.svg
                        .bottom-150.right-250
                            img.width-450(src=imgAssets+'motion_force.svg')
            +frameInbox('Euler Integration')
                .important-orange
                    ul
                        li.fragment(data-fragment-index='1')
                            include ../assets/physics_dynamics/equations_generated/euler_01.svg
                    .scope.fragment(data-fragment-index='2')
                        p Explicit method
                        ul
                            li
                                include ../assets/physics_dynamics/equations_generated/euler_02.svg
                    .scope.fragment(data-fragment-index='3')
                        p Improved method
                        ul
                            li
                                include ../assets/physics_dynamics/equations_generated/euler_03.svg
                    .scope.fragment(data-fragment-index='4')
                        p Implicit method
                        ul
                            li
                                include ../assets/physics_dynamics/equations_generated/euler_04.svg
                    .space-md
                    ul
                        li.upside.fragment(data-fragment-index='5') cheap and easy to implement
                        li.downside.fragment(data-fragment-index='6') high error and poor stability, depending <br>directly on the time step
                    .top-60.right-30.fragment(data-fragment-index='1')
                        img.height-350(src=imgAssets+'euler_curve.svg')
                    .bottom-30.right-30.fragment(data-fragment-index='5')
                        img.height-350(src=imgAssets+'euler_comparison.svg')
                    .top-170.left-330.fragment(data-fragment-index='2')
                        img.width-50(src=imgAssets+'euler_explicit.svg')
                    .top-300.left-330.fragment(data-fragment-index='3')
                        img.width-50(src=imgAssets+'euler_improved.svg')
                    .top-440.left-330.fragment(data-fragment-index='4')
                        img.width-50(src=imgAssets+'euler_implicit.svg')

            - var imgAssets = '../assets/physics_steering/';
            +mchapter('Physics: Steering Behaviors', imgAssets+'chapter_steering.svg')
            +frameInbox('Steering Behaviors')
                .important-orange
                    ul
                        li.fragment set of algorithms and principles that help autonomous agents move in a realistic manner by using simple forces
                        li.fragment designed by <span class="highlight-2">Crag Reynolds</span> in the early 90's
                        li.mt-20.fragment <span class="highlight">Agent</span> - a system situated within an envirnoment, with an ability to sense that environment
                        li.mt-20.fragment <span class="highlight">Motion layers</span>
                            ul
                                li.fragment action selection - choosing goals, strategy
                                li.highlight-2.fragment steering - trajectory calculation
                                li.fragment locomotion - way of moving, animation, articulation
                    .text-center.mt-10.fragment
                        img.height-300(src=imgAssets+'steering_agent.svg')
            +frameInbox('Steering Behaviors')
                .important-orange
                    .scope.fragment
                        p Seek
                        ul
                            li.fragment the simplest steering behavior
                            li.fragment a force that directs an agent toward a target position
                        .space-md
                        .text-center
                            img.height-500(src=imgAssets+'steering_seek.svg')
            +frameInbox('Steering Behaviors')
                .important-orange
                    .scope.fragment(data-fragment-index='1')
                        p Flee
                        ul
                            li.fragment(data-fragment-index='2') opposite of seek
                            li.fragment(data-fragment-index='3') creates a force that steers the agent away
                    .scope.fragment(data-fragment-index='4')
                        p Arrive
                        ul
                            li.fragment(data-fragment-index='5') seek + stopping movement
                            li.fragment(data-fragment-index='6') decelerates the agent onto the target position, based on given slowing radius
                        .space-md
                    .text-center.fragment(data-fragment-index='4')
                        img.height-400(src=imgAssets+'steering_arrive.svg')
            +frameInbox('Steering Behaviors')
                .important-orange
                    .scope.fragment(data-fragment-index='1')
                        p Pursuit
                        ul
                            li.fragment(data-fragment-index='2') agent intercepts a moving target
                            li.fragment(data-fragment-index='3') predicts where the target is going to be in the future
                            li.fragment(data-fragment-index='4') calls for a good prediction function
                    .scope.fragment(data-fragment-index='5')
                        p Evade
                        ul
                            li.fragment(data-fragment-index='6') opposite of pursuit
                            li.fragment(data-fragment-index='7') the evader flees from the estimated future position
                    .space-md
                    .text-center.fragment(data-fragment-index='1')
                        img.height-350(src=imgAssets+'steering_evade.svg')
            +frameInbox('Steering Behaviors')
                .important-orange
                    .scope.fragment
                        p Wander
                        ul
                            li.fragment produces a force that will give an impression of a <span class="highlight">random walking</span>
                            li.fragment small random displacement is applied to the velocity vector every frame
                            li.fragment a circle is projected in front of the vehicle
                            li.fragment the vehicle is steered toward a target that moves along the perimeter
                            li.fragment parameters: circle radius, distance from the vehicle and jittering (randomness)
                        .space-md
                        .text-center
                            img.height-420(src=imgAssets+'steering_wander.svg')
            +frameInbox('Steering Behaviors')
                .important-orange
                    .scope.fragment
                        p Path follow
                        ul
                            li.fragment moves a vehicle along a set of waypoints
                            li.fragment the last waypoint can be reached using <span class="highlight">arrive</span>, the others via <span class="highlight">seek</span>
                            li.fragment smooth movement can be achieved using a <span class="highlight">tolerance radius</span> or Bézier curve approximation
                            li.fragment very sensitive to configuration (max force, max velocity, radius,...)
                        .text-center.mt-10.fragment
                            img.height-500(src=imgAssets+'steering_follow.svg')

            - var imgAssets = '../assets/physics_engines/';
            +mchapter('Physics: Physics Engine', imgAssets+'chapter_physics.svg')
            +frameInbox('Physics engine')
                .important-orange
                    ul
                        li system that <span class="highlight">approximates</span> physical phenomena in real-time
                        li computes dynamics of objects in virtual scene
                        li you have to understand your game before you decide how to add a physical simulation to it
                        li.mt-40.upside can improve immersion
                        li.upside can support new gameplay events
                        li.downside can broke the game story
                        li.downside can take up significant computing resources
            +frameInbox('Object types')
                .important-orange
                    .scope.mt-10.fragment
                        p Body
                        ul
                            li.fragment fundamental object in the physics scene
                    .scope.mt-10.fragment
                        p Rigid Body
                        ul
                            li.fragment idealized, infinitely hard, non-deformable solid object
                            li.fragment <span class="highlight-2">physics-driven bodies</span> - driven entirely by the simulation
                            li.fragment <span class="highlight-2">game-driven bodies</span> - moved in a non-physical way (animations)
                            li.fragment <span class="highlight-2">fixed bodies</span> - collision-only bodies (e.g. triggers)
                    .scope.mt-10.fragment
                        p Soft body
                        ul
                            li.fragment deformable
                    .scope.mt-10.fragment
                        p Shape
                        ul
                            li.fragment region of space described by a boundary, with a definite inside and outside (curved line, polygon, curved surface, polyhedron)
                    .scope.mt-10.fragment
                        p Fixture
                        ul
                            li.fragment used to describe size, shape and material properties
                    .right-50.top-250
                        img.height-350(src=imgAssets+'cube.png')
            +frameInbox('Object Types')
                .important-orange
                    .scope.fragment
                        p Constraint
                        ul
                            li.fragment connects bodies together in order to simulate interaction (ropes, wheels, vehicles, chains)
                    .scope.fragment
                        p Sensor/Phantom
                        ul
                            li.fragment entity that provides a feedback when certain objects overlap
                            li.fragment participates on collision detection but doesn't affect the scene
                    .scope.fragment
                        p Rag doll
                        ul
                            li.fragment displays human-like figures with a realistic motion
                    .scope.fragment
                        p Destructible object
                        ul
                            li.fragment breakable object, can be implemented by using rigid body dynamics, dividing the model into a number of breakable pieces
            +frameInbox('Constraints')
                .important-orange
                .flex.flex-row.justify-evenly.center
                    figure.fragment
                        img.height-500(src=imgAssets+'constraint_rope.svg')
                        p rope
                    figure.fragment
                        img.height-500(src=imgAssets+'constraint_revolute.svg')
                        p revolute
                    figure.fragment
                        img.height-500(src=imgAssets+'constraint_prismatic.svg')
                        p prismatic
                    figure.fragment
                        img.height-500(src=imgAssets+'constraint_conetwist.svg')
                        p cone-twist
            +frameInbox('Particle Systems')
                .important-orange
                    ul
                        li.fragment a collection of point masses that obeys certain physical laws
                        li.fragment can model complex fuzzy shapes and dynamics
                        li.fragment uses Flyweight pattern (array of positions, velocities, group lists)
                        li.fragment particles are not only moving points! Even a tree may become a particle
                    .scope.fragment
                        p Applications
                        ul.leading-md
                            li.highlight-2.fragment fluids
                            li.fragment visual effects
                            li.fragment flocks
                            li.fragment rendered trails (plants)
                            li.fragment soft bodies (flag, cloth)
                    .scope.fragment
                        p Basic model
                        ol.leading-md
                            li.fragment generate new particles
                            li.fragment assign individual attributes
                            li.fragment extinguish dead particles
                            li.fragment move and transform particles according to their dynamic values
                            li.fragment render meshes
                    .right-20.bottom-150
                        img.height-400(src=imgAssets+'particles.gif')
                    .right-350.bottom-150
                        img.height-400(src=imgAssets+'flame.gif')
            - var imgAssets = '../assets/physics_collisions/';
            +mchapter('Physics: Collision Detection', imgAssets+'chapter_collisions.svg')
            +frameInbox('Primitives')
                .important-orange
                    .scope.fragment
                        p Sphere
                        ul
                            li.fragment center point and radius (4 numbers for 3D)
                    .scope.fragment
                        p Capsule
                        ul
                            li.fragment 2D: rectangle and two circles
                            li.fragment 3D: cylinder and two hemispherical end-caps
                            li.fragment representation: two points and radius
                        .text-center
                            img.height-120(src=imgAssets+'primitives_capsule.svg')
                    .scope.fragment
                        p AABB
                        ul
                            li.fragment axis-aligned bounding box
                            li.fragment rectangular volume (cuboid) whose faces are parallel to the axes of the coordinate system
                            li.upside.fragment very efficient test for penetration
                            li.downside.fragment AABB must be recalculated whenever the object rotates
            +frameInbox('Primitives')
                .important-orange
                    .scope.fragment
                        p OBB
                        ul
                            li.fragment oriented bounding box
                            li.fragment defined by a position, half-extents and orientation
                            li.fragment commonly used
                        .top-50.right-100
                            img.width-350(src=imgAssets+'primitives_obb.svg')
                    .scope.fragment
                        p k-DOP
                        ul
                            li.fragment discrete oriented polytope
                            li.fragment more general case of AABB and OBB
                            li.fragment approximates the shape of an object
                        .top-350.right-100
                            img.width-350(src=imgAssets+'primitives_kdop.svg')
                    .scope.fragment
                        p Convex volume
                        ul
                            li.fragment more general shape
                            li.fragment must be convex
                            li.fragment expensive for intersection test
                        .top-630.right-100
                            img.width-350(src=imgAssets+'primitives_convex.svg')
            +frameInbox('SAT')
                .important-orange
                    .scope.fragment
                        p SAT (separating axis theorem)
                        ul
                            li.fragment based on collection of intersection tests
                            li.fragment if an axis can be found along which the projection of two <span class="highlight-2">convex</span> shapes do not overlap, then the two shapes do not intersect
                            li.fragment for 2D: AABB 2 axes, OBB 4 axes
                            li.fragment for 3D: AABB 3 axes, OBB 15 axes
                        .bottom-0.right-50
                            img.height-600(src=imgAssets+'sat.svg')
                    .scope.fragment
                        p Other methods
                        ul
                            li.fragment GJK, Line Sweep, Sphere test
            +frameInbox('Tunneling problem')
                .important-orange
                    .scope.fragment
                        p Stepped world
                        ul.leading-md
                            li.fragment time steps vary based on occurring situation
                            li.fragment collision time is calculated by doing binary search in time, moving object back and forth by 1/2 steps (5 iterations is usually enough)
                        .text-center
                            img.height-230(src=imgAssets+'stepped_world.svg')
                    .scope.mt-10.fragment
                        p Continuous Collision Detection (CCD)
                        ul.leading-md
                            li.fragment uses <span class="highlight-2">Swept Shapes</span> technique
                            li.fragment a new shape is formed by the motion of the original one
                            li.fragment rotating shapes may result in shapes that aren't convex
                        .text-center
                            img.height-160(src=imgAssets+'ccd.svg')

            +summary_lecture08()


            - var imgAssets = '../assets/graphics_space/';
            +mchapter('Graphics: Space', imgAssets+'chapter_space.svg')
            +frameInbox('Space')
                .important-orange
                    .scope.fragment
                        p Model Space
                        ul.leading-md
                            li.fragment origin is usually placed at a central location (center of mass)
                            li.fragment axes are aligned to natural direction of the model
                    .scope.fragment
                        p World Space
                        ul.leading-md
                            li.fragment fixed coordinate space, in which the transformations of all objects in the game world are expressed
                    .scope.fragment
                        p View/Camera Space
                        ul.leading-md
                            li.fragment coordinate frame fixed to the camera
                            li.fragment space origin is placed at the focal point of the camera
                            li.fragment OpenGL: camera faces toward negative <span class="italic">z</span>
                    .scope.fragment
                        p Clip Space
                        ul.leading-md
                            li.fragment a rectangular prism extending from -1 to 1 (OpenGL)
                    .scope.fragment
                        p View/Screen Space
                        ul.leading-md
                            li.fragment a region of the screen used to display a portion of the final image
            +frameInbox('World-Model-View')
                .important-orange
                    .center
                        img.height-750(src=imgAssets+'world-model-view.svg')
            +frameInbox('Clip Space')
                .important-orange
                    .center
                        img.height-750(src=imgAssets+'clip_space.svg')
            +frameInbox('View Volume')
                .important-orange
                    ul
                        li.fragment <span class="highlight">View volume</span> - region of space the camera can see
                        li.fragment <span class="highlight">Frustum</span> - the shape of view volume for perspective projection
                        li.fragment <span class="highlight">Rectangular prism</span> - the shape of view volume for orthographic projection
                        li.fragment <span class="highlight">Field of View (FOV)</span> - the angle between the top and bottom of a 2D surface of the projected world
                    .space-md
                    .flex-cols-2.fragment
                        figure
                            img.height-400(src=imgAssets+'projection_perspective.svg')
                            p Perspective projection
                        figure
                            img.height-400(src=imgAssets+'projection_ortographic.svg')
                            p Orthographic projection

            - var imgAssets = '../assets/graphics_animations/';
            +mchapter('Graphics: Animations', imgAssets+'chapter_animations.svg')
            +frameInbox('Interpolation')
                .important-orange
                    ul
                        li.fragment method that calculates semi-points within the range of given points
                    .scope.fragment
                        p Applications
                        ul
                            li.fragment graphics - image resizing
                            li.fragment animations - transformation morphing
                            li.fragment multiplayer - game state morphing
                            li.fragment audio/video - sample/keyframe interpolation
                        .bottom-80.right-40
                            img.height-600(src=imgAssets+'interpolation.svg')
                    .scope.fragment
                        p Main methods
                        ul
                            li.fragment Constant interpolation (none/hold)
                            li.fragment Linear interpolation
                            li.fragment Cosine interpolation
                            li.fragment Cubic interpolation
                            li.fragment Bézier interpolation
                            li.fragment Hermite interpolation
                            li.fragment SLERP (spherical linear interpolation)
                        +tipKeen('SLERP is widely used in animation blending').bottom-0.right-350

            - var imgAssets = '../assets/graphics_processing/';
            +mchapter('Graphics: GPU processing', imgAssets+'chapter_gpu.svg')
            +frameInbox('Terms')
                .important-orange
                    .scope.fragment
                        p Vertex
                        ul.leading-md
                            li.fragment primarily a point in 3D space with x, y, z coordinates
                            li.fragment attributes: position vector, normal, color, uv coordinates, skinning weights,...
                    .scope.fragment
                        p Fragment
                        ul.leading-md
                            li.fragment a sample-sized segment of a rasterized primitive
                            li.fragment its size depends on sampling method
                    .scope.fragment
                        p Texture
                        ul.leading-md
                            li.fragment a piece of bitmap that is applied to a model
                    .scope.fragment
                        p Occlusion
                        ul.leading-md
                            li.fragment rendering two triangles that overlap each others
                            li.fragment Z-fighting issue
                                .right-60.top-500
                                    figure
                                        img.height-250(src=imgAssets+'zfighting.png')
                                        p Z-Fighting
                            li.fragment solution: more precise depth buffer
                    .scope.fragment
                        p Culling
                        ul.leading-md
                            li.fragment process of removing triangles that aren't facing the camera
                            li.fragment frustum culling, portals, anti-portals,...
            +frameInbox('Shaders')
                .important-orange
                    ul
                        li.fragment programs that run on the video card in order to perform a variety of specialized functions (lighting, effects, post-processing, physics, AI)
                    .scope.fragment
                        p Vertex shader
                        ul
                            li.fragment input is vertex, output is transformed vertex
                    .scope.fragment
                        p Geometry shader (optional)
                        ul
                            li.fragment input is n-vertex primitive, output is zero or more primitives
                    .scope.fragment
                        p Tessellation shader (optional)
                        ul
                            li.fragment input is primitive, output is subdivided primitive
                    .scope.fragment
                        p Pixel (fragment) shader
                        ul
                            li.fragment input is fragment, output is color, depth value, stencil value
                            li.fragment widely used for visual effects
                    .scope.fragment
                        p Compute shader
                        ul
                            li.fragment shader that runs outside of the rendering pipeline (e.g. CUDA)

            - var imgAssets = '../assets/graphics_concepts/';
            +mchapter('Graphics: Rendering concepts', imgAssets+'chapter_graphics.svg')
            +frameInbox('Other techniques')
                .important-orange
                    .scope.fragment(data-fragment-index='1')
                        p LOD
                        ul
                            li.fragment(data-fragment-index='2') level of detail, boosts draw distance
                            li.fragment(data-fragment-index='3') pioneered with Spyro the Dragon Series
                    .scope.fragment(data-fragment-index='4')
                        p Texture mapping
                        ul
                            li.fragment(data-fragment-index='5') mapping of 2D surface (texture map) onto a 3D object
                            li.fragment(data-fragment-index='6') early games have issues with perspective correctness
                            li.fragment(data-fragment-index='7') common use - UV mapping
                    .scope.fragment(data-fragment-index='8')
                        p Baking
                        ul
                            li.fragment(data-fragment-index='9') a.k.a rendering to texture
                            li.fragment(data-fragment-index='10') generating texture maps that describe different properties of the surface of a 3D model
                            li.fragment(data-fragment-index='11') effects are pre-calculated in order to save computational time and circumvent hardware limits
                    .top-50.right-40.fragment(data-fragment-index='1')
                        img.height-300(src=imgAssets+'lod.png')
                    .top-300.right-40.fragment(data-fragment-index='7')
                        img.height-290(src=imgAssets+'uv_mapping.png')
                    .top-350.right-450.fragment(data-fragment-index='6')
                        img.height-200(src=imgAssets+'texture_mapping.svg')
                    .bottom-10.right-40.fragment(data-fragment-index='8')
                        img.height-170(src=imgAssets+'normal_map.png')

            +summary_lecture09()


            - var imgAssets = '../assets/gameai_introduction/';
            +mchapter('Game AI: AI introduction', imgAssets+'chapter_gameai.svg')
            +frameInbox('Challenges for Game AI')
                .important-orange
                    .scope.fragment.fade-up
                        p Game AI features and limits
                        ul
                            li.fragment.fade-up real-time
                            li.fragment.fade-up limited resources
                            li.fragment.fade-up incomplete knowledge
                            li.fragment.fade-up planning
                            li.fragment.fade-up learning
                    .scope.fragment.fade-up
                        p Game AI properties
                        ul
                            li.fragment.fade-up predictability and unpredictability (surprise elements)
                            li.fragment.fade-up support - communication between NPC and the player
                            li.fragment.fade-up surprise - harassment, ambush, team support,...
                            li.highlight-2.fragment.fade-up winning well and losing well
                            li.fragment.fade-up cheating - acceptable as long as it doesn't get detected by the player
                    +tipKeen('The AI must be fun to play against, not beat the player easily').bottom-0.left-0
        
            - var imgAssets = '../assets/gameai_mobs/';
            +mchapter('Game AI: AI for mobs', imgAssets+'chapter_mobs.svg')
            +frameInbox('Scripting')
                .important-orange
                    ul
                        li.fragment(data-fragment-index='1') <span class="highlight">IF-THIS-THEN-THAT</span>
                        li.fragment(data-fragment-index='2') AI behavior is completely hardcoded
                        li.upside.fragment(data-fragment-index='2') simple, easy to debug, easy to extend
                        li.downside.fragment(data-fragment-index='3') human player should behave as the developers expected
                        li.downside.fragment(data-fragment-index='4') good scripting behavior must cover a large amount of situations
                    .code.text-sm.mt-10.fragment(data-fragment-index='5')
                        include ../assets/gameai_mobs/snippets_generated/doom_chase.html
                    .right-0.bottom-0.fragment(data-fragment-index='5')
                        img.height-500(src=imgAssets+'doom_chase.png')
            +frameInbox('Finite State Machine')
                .important-orange
                    ul
                        li.fragment the oldest and most commonly used formalism to model game AIs
                        li.fragment useful for entities with a small set of distinct states
                            .bottom-300.right-20
                                img.height-320(src=imgAssets+'dungeon.jpg')
                        li.fragment each entity can be in <span class="highlight-2">exactly one</span> of a finite number of states at any time
                        li.mt-20.fragment <span class="highlight font-bold">Definition</span>
                            ul
                                li.fragment quadruple: 
                                    include ../assets/gameai_mobs/equations_generated/fsm_01.svg
                                li.fragment 
                                    include ../assets/gameai_mobs/equations_generated/fsm_02.svg
                                    |&nbsp;is a finite, non-empty set of states
                                li.fragment
                                    include ../assets/gameai_mobs/equations_generated/fsm_03.svg
                                    |&nbsp;is a finite set of inputs
                                li.fragment
                                    include ../assets/gameai_mobs/equations_generated/fsm_04.svg
                                    |&nbsp;is the state-transition function
                                li.fragment
                                    include ../assets/gameai_mobs/equations_generated/fsm_05.svg
                                    |&nbsp;is an initial state, 
                                    include ../assets/gameai_mobs/equations_generated/fsm_06.svg
                        li.mt-20.fragment can be implemented via polymorphism or a state transition table
                        li.downside.fragment unmanageable for large complex systems, leading to transition explosion
            +frameInbox('Hierarchical state machine')
                .important-orange
                    ul
                        li.fragment also known as <span class="highlight">statecharts</span>
                        li.fragment each state can have a superstate or a set of substates
                        li.fragment groups of states share transitions
                        li.fragment usually implemented as a stack
                            ul
                                li.fragment push a low-level state on the stack when entered
                                li.fragment pop and move to the next state when finished
                    .text-center.fragment
                        img.height-440(src=imgAssets+'hfsm_doomguard.svg')
                        .bottom-40.right-20
                            img.height-400(src=imgAssets+'fsm_doomguard.png')
            +frameInbox('Behavior Tree')
                .important-orange
                    ul
                        li.fragment tree of hierarchical nodes that control decision making process
                        li.fragment originated from gaming industry since Halo 2 (2004)
                        li.fragment combines elements from both Scripting and HFSMs
                        li.fragment there is no standardized formalization
                        li.fragment depth-first traversal, starting with the root node
                        li.fragment each executed behavior passes back and returns a status
                            ul
                                li.highlight.code SUCCESS, FAILURE, RUNNING, (SUSPENDED)
                    .text-center.mt-20.fragment
                        img.height-400(src=imgAssets+'btree.jpg')
            +frameInbox('Behavior Tree')
                .important-orange
                    .text-center.fragment
                        img.height-350(src=imgAssets+'btree.svg')
                    .space-md
                    .center.text-center
                        table.fragment
                            tr
                                th Node Type
                                th Success
                                th Failure
                                th Running
                            tr
                                td.color-lemon Selector
                                td If one child succeeds
                                td If all children fail
                                td If one child is running
                            tr
                                td.color-lemon Sequence
                                td If all children succeed
                                td If one child fails
                                td If one child is running
                            tr
                                td.color-lemon Decorator
                                td It depends
                                td It depends
                                td It depends
                            tr
                                td.color-lemon Parallel
                                td If N children succeed
                                td If M-N children succeed
                                td If all children are running
                            tr
                                td.color-lemon Action
                                td When completed
                                td Upon an error
                                td During completion
                            tr
                                td.color-lemon Condition
                                td If true
                                td If false
                                td Never

            - var imgAssets = '../assets/gameai_strategies/';
            +mchapter('Game AI: AI in strategies', imgAssets+'chapter_rts.svg')
            +frameInbox('Real-time strategy')
                .important-orange
                    ul
                        li.italic.highlight-2.fragment Real-time strategy is a Bayesian, zero-sum game (Rubinstein, 1994)
                            .bottom-0.right-0
                                img.height-500(src=imgAssets+'totalwar.jpg')
                        li.fragment a game where the player is in control of certain, usually military, assets, with which the player can manipulate in order to achieve victory
                        li.fragment goal: build up a base, gather resources, produce army, destroy the enemy
                        li.fragment <span class="highlight-2">methods:</span> layer-based AI, rule-based AI
                    .scope.fragment
                        p Main elements
                        ul
                            li.fragment map, mini-map
                            li.fragment resources
                            li.fragment units and their attributes
                            li.fragment buildings
                    .scope.fragment
                        p Other features
                        ul
                            li.fragment real-time aspect (no turns)
                            li.fragment fog of war
                            li.fragment tech tree
            +frameInbox('RTS Features')
                .important-orange
                    .scope.fragment
                        p Resource Control
                        ul.leading-md
                            li.fragment minerals, gas, oil, trees,...
                            li.fragment controlling more resources increases the players' constsruction capabilities
                    .scope.mt-5.fragment
                        p Tech tree
                        ul.leading-md
                            li.fragment a directed acyclic graph that contains the whole technological development of a faction
                    .scope.mt-5.fragment
                        p Build order (opening)
                        ul.leading-md
                            li.fragment the timing at which the first buildings are constructed                .scope.mt-5.fragment
                        p Fog of war
                        ul.leading-md
                            li.fragment fog that covers the parts of the map the player has not yet explored
                            li.fragment requires to scout unexplored areas to find enemy sources
                    .scope.mt-5.fragment
                        p Micromanagement
                        ul.leading-md
                            li.fragment way of controlling units in detail while they are in combat
                    .scope.mt-5.fragment
                        p Tactics
                        ul.leading-md
                            li.fragment a set of specific actions used when applying a strategy
                    .scope.mt-5.fragment
                        p Strategy
                        ul.leading-md
                            li.fragment making decisions knowing what we saw from the opponent

            +summary_lecture10()


            - var imgAssets = '../assets/multiplayer_architecture/';
            +mchapter('Multiplayer: Networking Architecture', imgAssets+'chapter_architecture.svg')
            +frameInbox('Peer-to-peer architecture')
                .important-orange
                    ul
                        li.fragment(data-fragment-index='1') each device exchanges data with each other in a fully connected graph
                        li.fragment(data-fragment-index='2') used in <span class="highlight">Doom</span>, early <span class="highlight">Command & Conquer</span> series, <span class="highlight">Age of Empires</span>, <span class="highlight">Starcraft</span>
                        li.fragment(data-fragment-index='3') given 
                            include ../assets/multiplayer_architecture/equations_generated/peer_to_peer_01.svg
                            |&nbsp;peers, each must have 
                            include ../assets/multiplayer_architecture/equations_generated/peer_to_peer_02.svg
                            |&nbsp;connections -> 
                            include ../assets/multiplayer_architecture/equations_generated/peer_to_peer_03.svg
                            |&nbsp;in total
                        li.fragment(data-fragment-index='4') methods: single master, partial authority, full replication
                    .space-xl
                    .text-center.fragment(data-fragment-index='1')
                        img.height-300(src=imgAssets+'arch_peer_to_peer.svg')
            +frameInbox('Client-Server architecture')
                .important-orange
                    ul
                        li.fragment(data-fragment-index='1')
                            include ../assets/multiplayer_architecture/equations_generated/client_server_01.svg
                            |&nbsp;devices, 
                            include ../assets/multiplayer_architecture/equations_generated/client_server_02.svg
                            |&nbsp;connections
                        li.fragment(data-fragment-index='2') server must handle 
                            include ../assets/multiplayer_architecture/equations_generated/client_server_03.svg
                            |&nbsp;more messages per second
                        li.fragment(data-fragment-index='3') server quickly becomes the bottleneck (lack of power and bandwidth)
                        li.fragment(data-fragment-index='5') <span class="highlight">Dedicated server</span> - only runs the game state and communicates
                        li.fragment(data-fragment-index='6') <span class="highlight">Listen server</span> - server is an active participant in the game itself
                    .text-center.mt-40.fragment(data-fragment-index='1')
                        img.height-400(src=imgAssets+'arch_client_server.svg')

            - var imgAssets = '../assets/multiplayer_transport/';
            +mchapter('Multiplayer: Transport', imgAssets+'chapter_transport.svg')
            +frameInbox('Message Types')
                .important-orange
                    .scope.fragment
                        p Stream
                        ul.leading-md
                            li.fragment doesn't need to be confirmed, contains a collection of continuous values
                            li.fragment e.g. dynamic objects and their attributes (transformation)
                    .scope.mt-7.fragment
                        p Snapshot
                        ul.leading-md
                            li.fragment complete information of the game state, sent either on demand or at given intervals
                    .scope.mt-7.fragment
                        p Command
                        ul.leading-md
                            li.fragment messages that have an impact on the game state, have to be confirmed
                            li.fragment e.g.: UNIT_CREATED, UNIT_DESTROYED, BUILDING_COMPLETED
                    .scope.mt-7.fragment
                        p Action
                        ul.leading-md
                            li.fragment high-priority messages (player's inputs, fire button,...)
                    .scope.mt-7.fragment
                        p Procedure Call
                        ul.leading-md
                            li.fragment a generic message that allows to call any function (play sound, load assets, reset animation)
                    .scope.mt-7.fragment
                        p Connection messages
                        ul.leading-md
                            li.fragment messages for handshake, ID assignment, disconnect, etc.
                    .scope.mt-7.fragment
                        p Beacon
                        ul.leading-md
                            li.fragment regular messages to inform the server that the connection is still on
            +frameInbox('Replication')
                .important-orange
                    ul
                        li.fragment the act of transmitting a state of an object from one device to another
                        li.fragment each object must be uniquely identified (network ID)
                        li.fragment the network message contains a type of an object and all parameters required to construct it
                    .code.text-sm.mt-80.fragment
                        include ../assets/multiplayer_transport/snippets_generated/replication.html
            +frameInbox('Reliability')
                .important-orange
                    ul
                        li.fragment packets may get lost
                        li.fragment server keeps sending messages that have an impact on the game state until the client accepts them
                    .text-center.mt-100.fragment
                        img.height-450(src=imgAssets+'reliability.svg')
            +frameInbox('Ordering')
                .important-orange
                    ul
                        li.fragment packets may arrive in a different order
                        li.highlight-2.fragment the client shouldn't apply a command message to its state before it applies all previous messages
                    .text-center.mt-100.fragment
                        img.height-450(src=imgAssets+'order.svg')

            - var imgAssets = '../assets/multiplayer_synchronization/';
            +mchapter('Multiplayer: Synchronization', imgAssets+'chapter_synchronization.svg')
            +frameInbox('Server-side rewind')
                .important-orange
                    ul
                        li.fragment dealing with instant actions that affect the gameplay (e.g. instant hit in FPS)
                        li.fragment occurs due to the inaccuracies of dead reckoning and time dilation
                        li.fragment server may change a state that has already been confirmed
                    .scope.fragment
                        p Source engine's solution
                        ul
                            li.fragment rewinds state on the server to exactly the state in which the player fired
                            li.fragment server stores the poses of every relevant object for X last frames and looks up the two frames between which the client was interpolating
                    .flex-cols-2.fragment
                        figure
                            img.height-360(src=imgAssets+'cs_wrong.jpg')
                            p Wrong
                        figure
                            img.height-360(src=imgAssets+'cs_correct.jpg')
                            p Correct
            +frameInbox('Latency handling summary')
                .important-orange
                    .scope.fragment
                        p Time dilation
                        ul
                            li delays the values by a few frames and interpolates to them
                    .scope.fragment
                        p Deterministic prediction
                        ul
                            li runs simulated code, masks latency and keeps the client's state in sync
                    .scope.fragment
                        p Dead reckoning
                        ul
                            li non-deterministic prediction
                            li client uses the last known state of an object to extrapolate future state
                    .scope.fragment
                        p Server-side rewind
                        ul
                            li the server buffers object positions for several frames to match the client's view when processing instant events
                    +tipKeen('It is better to be wrong on time than right but late').bottom-0.left-0

            +summary_lecture11()
            // ============================================================

    +footer('Adam Vesecký (FIT CTU)', 'Architecture of Computer Games')
    script(src!='../../scripts/reveal-setup.js')

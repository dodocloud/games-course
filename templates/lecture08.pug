doctype html
- var bgr = './static/slides/bgr/bgr_08.jpg'
include ./partial/header.pug
include ./partial/title.pug
include ./partial/containers.pug
include ./partial/texts.pug

+header('MI-APH - Lecture08', 'Lecture 8: Graphics', 'lecture08')
// ===================================================== SLIDES =====================================================
.reveal
  .slides
    // ============================================================
    +msection(bgr)
      .lecture-logo.mb80
        include ../static/slides/svg/lecture08/lecture08_logo.svg
      +title('Graphics')
    // ============================================================
    +chapter(bgr, 'Positioning')
    // ============================================================
    +mframeGreen(bgr, 'Homogeneous Coordinates')
      ul
        li
          +strtext('in Euclidean geometry we use', 'Cartesian coordinates')
        li
          +strtext('in projective geometry we use', 'Homogeneous coordinates')
        li we can express all affine transforms and projections as one matrix
        li transformations can be composed by matrix multiplication
        li
          include ../build_pre/equations/lecture08/coordinates_01.svg
          |&nbsp;for points, 
          include ../build_pre/equations/lecture08/coordinates_02.svg
          |&nbsp;for vectors
      ul
        li Example: homogeneous matrix 
          include ../build_pre/equations/lecture08/coordinates_03.svg
          |&nbsp;of a rotation matrix 
          include ../build_pre/equations/lecture08/coordinates_04.svg
          |&nbsp;and a position vector 
          include ../build_pre/equations/lecture08/coordinates_05.svg
          ul
            li 
              include ../build_pre/equations/lecture08/coordinates_06.svg
        li 
          span.highlight-sec Homogeneous coordinates -> Cartesian coordinates
          ul
            li
              include ../build_pre/equations/lecture08/coordinates_07.svg
        li 
          span.highlight-sec Cartesian coordinates -> Homogeneous coordinates
          ul
            li 
              include ../build_pre/equations/lecture08/coordinates_08.svg
    // ============================================================
    +mframeOrange(bgr, 'Rotation in 3D space')
      div.tcenter
        img.h900(src='../static/slides/svg/lecture08/pitch_yaw_roll.svg')
    // ============================================================
    +mframeOrange(bgr, 'Rotational representations')
      div.bottom-content.justify-right.fill
        img.h350(src='../static/slides/images/lecture08/mass_effect_glitch.gif')
      h4 Euler angles
      ul
        li Pitch, Yaw, Roll
        li.upside simple, small size (3 floats), intuitive nature
        li.downside the order in which the rotations are performed matters
        li.downside
          +strtext('', 'gimbal lock issue', '- when a 90-degree rotation causes one of the three principal axes to collapse onto another principal axis')
      h4.mt60 Axis + angle
      ul
        li axis of rotation plus a scalar for the angle of rotation 
          include ../build_pre/equations/lecture08/rot_representations.svg
        li.upside intiutive and compact
        li.downside rotations cannot be easily interpolated
        li.downside rotations cannot be applied to vectors directly
    // ============================================================
    +mframeOrange(bgr, 'Rotational representations')(class='space-vert-m')
      h4 Quaternions
      ul
        li similar to axis + angle, however, this is an algebraic field
        li
          include ../build_pre/equations/lecture08/quaternions_01.svg
        li unit-length 
          include ../build_pre/equations/lecture08/quaternions_02.svg
        li.mt40 a unit quaternion can be visualised as a 3D vector + scalar
          ul
            li
              include ../build_pre/equations/lecture08/quaternions_03.svg
            li
              include ../build_pre/equations/lecture08/quaternions_04.svg
        li.upside permits rotations to be concatenated and applied directly 
        li.upside permits rotations to be easily interpolated
        li.downside can perform only one full rotation between keyframes
      .tcenter.w100.highlight-sec.mt30 
        span Usually, Euler angles are used for fast rotation around one axis<br> and quaternions for complex yet slow rotations around all axes
    // ============================================================
    +mframeGreen(bgr, 'Rotation in affine space')
      .bottom-content.justify-right
        img.h600(src='../static/slides/svg/lecture08/rotation_around_origin.svg')
      h4 Rotation about a fixed point 
        include ../build_pre/equations/lecture08/composite_01.svg
      ul
        li move 
          include ../build_pre/equations/lecture08/composite_01.svg
          |&nbsp;to the origin, rotate, move back
        li
          include ../build_pre/equations/lecture08/composite_02.svg
        li post-multiply order -> from the right or from bottom to top in the code
        li.highlight-sec the origin of the object matters
      h4.mt80 OpenGL example:
      .code.mt40
        include ../static/slides/snippets/lecture08/opengl_rotation.html
    // ============================================================
    +mframeOrange(bgr, 'Space')
      h4 Model space
      ul
        li origin is usually placed at a central location (center of mass)
        li axes are aligned to natural direction of the model (e.g. a nose of an animal)
      h4 World space
      ul
        li fixed coordinate space, in which the positions, orientations and scales of all objects in the game world are expressed
      h4 View/Camera space
      ul
        li coordinate frame fixed to the camera
        li space origin is placed at the focal point of the camera
        li OpenGL: camera faces toward negative 
          include ../build_pre/equations/lecture08/space.svg
      h4 Clip space
      ul
        li a rectangular prism extending from -1 to 1 (OpenGL)
      h4 View/screen space
      ul
        li a region of the screen used to display a portion of the final image
    // ============================================================
    +mframeOrange(bgr, 'World-model-view')
      div.tcenter
        img.h900(src='../static/slides/svg/lecture08/model_world_view.svg')
    // ============================================================
    +mframeGreen(bgr, 'Clip space')
      div.tcenter
        img.h900(src='../static/slides/svg/lecture08/clip_space.svg')
    // ============================================================
    +mframeOrange(bgr, 'View volume')
      ul
        li
          +strtext('', 'View volume', '- region of space the camera can see')
        li
          +strtext('', 'Frustum', '- the shape of view volume for perspective projection')
        li
          +strtext('', 'Rectangular prism', '- the shape of view volume for orthographic projection')
        li
          +strtext('', 'Field of view (FOV)', '- the angle between the top and bottom of the 2D surface on which the world will be projected')
      .columns-2
        figure
          img.h500(src='../static/slides/svg/lecture08/projection_persp.svg')
          p Perspective projection
        figure
          img.h500(src='../static/slides/svg/lecture08/projection_ortho.svg')
          p Orthographic projection
    // ============================================================
    +mframeGreen(bgr, 'Lookat vector')
      .bottom-content
        img.h700.ml80.mb40(src='../static/slides/images/lecture08/doomdoor.png')
      .bottom-content
        img.h800.mr100(src='../static/slides/svg/lecture08/lookat_vector.svg')
      ul
        li a unit vector that points in the same direction as the camera
        li if the dot product between 
          span.code.highlight lookAt 
          |vector and the normal vector of a polygon is lower than zero, the polygon is facing the camera
    // ============================================================
    +chapter(bgr, 'Animations')
    // ============================================================
    +mframeOrange(bgr, 'Animations')
      h4 Stop-motion animation
      ul
        li predefined set of images/sprites
        li simple and intuitive, but impossible to re-define without changing the assets
      h4 Keyframed animation
      ul
        li keyframes contain values (position, color, modifier,...) at given point of time
        li intermediate frames are 
          span.highlight-sec interpolated
      .columns-4
        figure
          img.h300(src='../static/slides/images/lecture08/anim_sprite.gif')
          p Sprite animation
        figure
          img.h300(src='../static/slides/images/lecture08/anim_spine.gif')
          p Skeletal 2D
        figure
          img.h300(src='../static/slides/images/lecture08/anim_skeletal.gif')
          p Skeletal 3D
        figure
          img.h300(src='../static/slides/images/lecture08/anim_vertex.gif')
          p Vertex
    // ============================================================
    +mframeOrange(bgr, 'Interpolation')
      div.bottom-content.justify-right
        img.h600(src='../static/slides/svg/lecture08/transform_cube.svg')
      div
        ul
          li.highlight Method that calculates points within the range of given points
          li.mt40
            span.highlight Applications
            ul
              li graphics - image resizing 
              li animations - morph between two transformations 
              li multiplayer - morph between two game states 
              li video - keyframe interpolation 
              li sound processing - sample interpolation 
          li
            span.highlight Main methods 
            ul
              li Constant interpolation (none/hold) 
              li.highlight-sec Linear interpolation 
              li Cosine interpolation 
              li Cubic interpolation 
              li BÃ©zier interpolation 
              li Hermite interpolation
    // ============================================================
    +mframeGreen(bgr, 'Bezier curve')
      ul
        li parametric curve defined by a set of control points
        li 
          +strtext('most common -', 'cubic curve,','4 points, 2 points provide directional information')
      div.tcenter
        img.h800(src='../static/slides/svg/lecture08/bezier_curve.svg')
    // ============================================================
    +mframeOrange(bgr, 'Linear interpolation')
      div.top-content.justify-right
        img.h400(src='../static/slides/svg/lecture08/linear_interpolation_1d.svg')
      div.center-content.justify-right
        img.mr500.h400(src='../static/slides/svg/lecture08/linear_interpolation_2d.svg')
      div.bottom-content.justify-right
        img.h400(src='../static/slides/svg/lecture08/linear_interpolation_3d.svg')
      h4 Linear interpolation
      ul
        li
          include ../build_pre/equations/lecture08/linear_interpolation.svg
        li for 1D values (time, sound)
      h4.mt100 Bilinear interpolation 
      ul
        li on a rectilinear 2D grid
        li for 2D values (images, textures)
        li Q - known points (closest pixels)
        li P - desired point
      h4.mt150 Trilinear interpolation
      ul
        li on a regular 3D grid
        li for 3D values (mipmaps)
    // ============================================================
    +mframe(bgr, 'Example: 1D interpolation')
      div.tcenter
        img.h900(src='../static/slides/svg/lecture08/keyframes.svg')
    // ============================================================
    +mframe(bgr, 'Example: 2D interpolation')
      div.tcenter
        img.h150(src='../static/slides/images/lecture08/scale_original.png')
      div.columns-4
        figure
          img.h500(src='../static/slides/images/lecture08/scale_nosamp.png')
          p No interpolation
        figure
          img.h500(src='../static/slides/images/lecture08/scale_constant.png')
          p Constant
        figure
          img.h500(src='../static/slides/images/lecture08/scale_bilinear.png')
          p Bilinar
        figure
          img.h500(src='../static/slides/images/lecture08/scale_cubic.png')
          p Cubic
    // ============================================================
    +chapter(bgr, 'Rendering pipeline')
    // ============================================================
    +mframe(bgr, 'Graphics api')
      .top-content.justify-right
        img.w300(src='../static/slides/images/lecture08/logo_directx.png')
      .center-content.justify-right
        img.w300(src='../static/slides/images/lecture08/logo_opengl.png')
      .bottom-content.justify-right
        img.w300.mb150(src='../static/slides/images/lecture08/logo_vulkan.png')
      h4 DirectX
      ul
        li since 1995
        li widely used for Windows and Xbox games
        li current version - DirectX 12
      h4 OpenGL
      ul
        li since 1992
        li concept of state machine
        li cross-platform
        li OpenGL ES - main graphics library for Android, iOS
        li WebGL - a subset variant of OpenGL for web
      h4 Vulkan
      ul
        li since 2015
        li referred as the next generation of OpenGL
        li lower overhead, more direct control over the GPU than OpenGL
        li unified management of compute kernels and shaders
    // ============================================================
    +mframeGreen(bgr, 'Triangle meshes')
      ul
        li the simplest type of polygons, always planar
        li.highlight all GPUs are designed around triangle rasterization
      ul
        li 
          span.highlight Constructing a triangle mesh
          ul
            li winding order (clockwise, counter-cw)
            li triangle lists, strips and fans
            li mesh instancing - shared data
      .tcenter
        img.h500(src='../static/slides/svg/lecture08/triangle_meshes.svg')
    // ============================================================
    +mframeOrange(bgr, 'Terms')
      .center-content.justify-right
        figure.mt150.mr50
          img.h300(src='../static/slides/images/lecture08/zfighting.png')
          p Z-Fighting
      h4 Vertex
      ul
        li primarily a point in 3D space with 
          include ../build_pre/equations/lecture08/pipeline_terms_01.svg
          |&nbsp;coordinates
        li attributes: position vector, normal, color, 
          include ../build_pre/equations/lecture08/pipeline_terms_02.svg
          |&nbsp;coordinates, skinning weights
      h4 Fragment
      ul
        li a sample-sized segment of a rasterized primitive
        li its size depends on sampling method
      h4 Texture
      ul
        li a piece of bitmap that is applied to a model
      h4 Occlusion
      ul
        li rendering two triangles that overlap each other
        li Z-Fighting issue
        li solution: more precise depth buffer
      h4 Culling
      ul
        li process of removing triangles that aren't facing the camera
        li frustum culling, portals, anti-portals,...
    // ============================================================
    +mframe(bgr, 'GPU architecture')
      div.tcenter
        img.h900(src='../static/slides/svg/lecture08/gpu_pipeline.svg')
    // ============================================================
    +mframeGreen(bgr, 'Rendering pipeline')
      ul
        li
          +strtext('', 'Vertex Fetch:', 'driver inserts the command in a GPU-readable encoding inside a pushbuffer')
        li
          +strtext('', 'Poly Morph Engine', 'of SM fetches the vertex data')
        li Warps of 32 threads are scheduled inside the SM
        li Vertex shaders in the warp are executed
        li H/D/G shaders are executed (optional step)
        li 
          +strtext('', 'Raster engine', 'generates the pixel information')
        li
          +strtext('data is sent to', 'ROP (Render Output Unit)')
        li ROP performs depth-testing, blending etc.
      .tcenter
        img.h450(src='../static/slides/svg/lecture08/rendering_pipeline.svg')
    // ============================================================
    +mframeGreen(bgr, 'Rendering pipeline')
      h4 Vertex shader phase
      ul
        li handles transformation from model space to view space
        li full access to texture data (height maps)
      h4 Tesselation shader phase (optional)
      ul
        li two shader stages and a fixed-function tessellator between them
        li
          +strtext2('', 'Tesselation Control Shader', '- determines the amount of tessellation')
        li
          +strtext2('', 'Tesselation Evaluation Shader', '- applies the interpolation')
      h4 Geometry shader phase (optional)
      ul
        li operates on entire primitives in homogeneous clip space
      h4 Rasterization phase
      ul
        li
          +strtext2('', 'Assembly', '- converts a vertex stream into a sequence of base primitives')
        li
          +strtext2('', 'Clipping', '- transformation of clip space to window-space and chopping off triangles that are outside the frustum')
        li
          +strtext2('', 'Culling', '- discards triangles facing away from the viewer')
        li
          +strtext2('', 'Rasterization', '- generates a sequence of fragments (window-space)')
    // ============================================================
    +mframeGreen(bgr, 'Rendering pipeline')
      h4 Fragment shader phase
      ul
        li input: fragment, output: color, depth value, stencil value
        li can address texture maps and run per-pixel calculations
      h4.mt60 Final phase
      ul
        li
          span.highlight-sec Additional culling tests
          ul
            li pixel ownership - fails if the pixel is not owned by the API (OpenGL)
            li scissor test - fails if the pixel lies outside of a screen rectangle
            li stencil test - comparing against stencil buffer
            li depth test - comparing against depth buffer
        li
          span.highlight-sec Color blending
          ul
            li combines colors from fragment shader with colors in the color buffers
        li writes data to framebuffer
        li swaps buffers
    // ============================================================
    +mframeOrange(bgr, 'Shaders')
      ul
        li programs that run on the video card in order to perform a variety of specialized functions (lighting, effects, post-processing, even physics or AI)
      h4 Vertex shader
      ul
        li input is vertex, output is transformed vertex
      h4 Geometry shader (optional)
      ul
        li input is n-vertex primitive, output is zero or more primitives
      h4 Tessellation shader (optional)
      ul
        li input is primitive, output is subdivided primitive
      h4 Pixel/fragment shader
      ul
        li input is fragment, output is color, depth value, stencil value
      h4 Compute shader
      ul
        li shader that run outside of the rendering pipeline
        li used for massively parallel GPGPU computing
    // ============================================================
    +mframe(bgr, 'Shader usecases')
      .top-content.justify-right
        figure
          img.h150(src='../static/slides/images/lecture08/tessellation.png')
          p Cube Tessellation
      .center-content.justify-right
        figure.mr50.mb50
          img.h250(src='../static/slides/images/lecture08/geom_shader.gif')
          p Geometry shader grass
      .bottom-content.justify-right
        figure.mr80
          img.h200(src='../static/slides/images/lecture08/screen_shader.gif')
          p Screen effects
      h4 Vertex shader
      ul
        li 3D-to-2D transformation
        li displacement mapping
        li skinning
      h4 Tessellation shader
      ul
        li Hull Shader - tessellation control
        li Domain Shader - tessellation evaluation
      h4 Geometry Shader
      ul
        li sprite-from-point transformation
        li cloth simulation
        li fractal subdivision
      h4 Pixel/fragment shader
      ul
        li bump mapping
        li particle systems
        li visual effects
    // ============================================================
    +mframe(bgr, 'Example: Geometry shader')
      .top-content.justify-right
        img.h500(src='../static/slides/svg/lecture08/geom_shader.svg')
      div.code
        include ../static/slides/snippets/lecture08/geometry_shader.html
    // ============================================================
    +mframeGreen(bgr, 'Raytracing')
      ul
        li conventional rendering converts each triangle into pixels on a 2D screen
        li
          span.highlight RayTracing 
          | provides realistic lighting by simulating the physical behavior of light
        li not possible in real-time until recently
        li the light traverses the scene, reflecting from objects, being blocked (shadows), passing through transparent objects (refractions), producing the final color 
        li APIs: OptiX, DXR, VKRay
      .columns-2
        figure
          img.h450(src='../static/slides/svg/lecture08/raytracing_conv.svg')
          p Rasterization
        figure
          img.h450(src='../static/slides/svg/lecture08/raytracing_ray.svg')
          p Ray Tracing
    // ============================================================
    +chapter(bgr, 'Effects and Textures') 
    // ============================================================
    +mframe(bgr, 'Rendering features')
      .columns-2
        figure.ml80
          img.h350(src='../static/slides/images/lecture08/effects_motion.jpg')
          p Motion blur
        figure.mr80
          img.h350(src='../static/slides/images/lecture08/effects_chroma.jpg')
          p Chromatic Aberration
      .columns-2
        figure.ml80
          img.h350(src='../static/slides/images/lecture08/effects_decal.jpg')
          p Decals
        figure.mr80
          img.h350(src='../static/slides/images/lecture08/effects_depthoffield.jpg')
          p Depth of field
    // ============================================================
    +mframe(bgr, 'Rendering features')
      .columns-2
        figure.ml80
          img.h350(src='../static/slides/images/lecture08/effects_caustics.jpg')
          p Caustics
        figure.mr80
          img.h350(src='../static/slides/images/lecture08/effects_lens.jpg')
          p Lens flare
      .columns-2
        figure.ml80
          img.h350(src='../static/slides/images/lecture08/effects_subsurfaces.jpg')
          p Subsurface Scattering
        figure.mr80
          img.h350(src='../static/slides/images/lecture08/effects_ao.jpg')
          p Ambient Occlusion
    // ============================================================
    +mframeGreen(bgr, 'Texture')
      .top-content.justify-right
        figure
          img.h400(src='../static/slides/images/lecture08/texture_mapping.gif')
          p Texture mapping
      .bottom-content.justify-right
        img.mb20.h350(src='../static/slides/images/lecture08/textures.jpg')
      ul
        li a piece of bitmap that is applied to an object
        li may be used as a look-up table for calculations
      h4 UV coordinates
      ul
        li texture coordinates, range from [0, 0] (bottom-left) to [1,1] (top-right)
        li uv mapping - projecting a texture onto an object
      h4 Texel
      ul
        li an individual texture element
      h4 Texture Mapping
      ul
        li application of a texel on a 3D model
      h4 Types
      ul
        li diffuse map
        li height map
        li normal map
        li specular map
        li ...
    // ============================================================
    +mframe(bgr, 'Example: UV mapping')
      div.tcenter
        img.h800(src='../static/slides/images/lecture08/uvmapping.jpg')
    // ============================================================
    +mframeGreen(bgr, 'Texture mapping')
      .top-content.justify-right
        img.h200.mt40.mr100(src='../static/slides/images/lecture08/mapping_bump.png')
      .center-content.justify-right
        img.h200.mr100(src='../static/slides/images/lecture08/mapping_normal.png')
      .bottom-content.justify-right
        img.h200.mb30.mr100(src='../static/slides/images/lecture08/mapping_displ.png')
      h4 Bump mapping
      ul
        li heightmap is used to generate normals
        li simple but not very accurate, heightmap uses only gray colors
      h4.mt200 Normal mapping
      ul
        li specifies a surface normal direction vector at each texel
        li uses RGB information as a 3D vector to give more accurate bump effect
      h4.mt150 Displacement mapping
      ul
        li heightmap is used to adjust vertices
        li provides realistic edges but requires a dense mesh
    // ============================================================
    +mframe(bgr, 'Example: Texture mapping')
      .grid32.w80.ml200
        figure
          img.h350(src='../static/slides/images/lecture08/texturemap_color.jpg')
          p Color texture
        figure
          img.h350(src='../static/slides/images/lecture08/texturemap_normal.jpg')
          p Normal texture
        figure
          img.h350(src='../static/slides/images/lecture08/texturemap_disp.jpg')
          p Displacement texture
        figure
          img.h350(src='../static/slides/images/lecture08/texture_color.jpg')
          p Color mapping
        figure
          img.h350(src='../static/slides/images/lecture08/texture_all.jpg')
          p Color + disp + normal
    // ============================================================
    +mframeGreen(bgr, 'Texture filtering')
      ul
        li there is not a clean one-to-one mapping between texels and pixels
        li GPU has to sample more than one texel and blend the resulting colors
      h4 Mipmapping
      ul
        li for each texture, we create a sequence of lower-resolution bitmaps
        li objects further from the camera will use low-res textures
      h4 Nearest neighbor
      ul
        li the closest texel to the pixel center is selected
      h4 Bilinear filtering
      ul
        li the four texels surrounding the pixel center are sampled, and the resulting color is a weighted average of their colors
      h4 Trilinear filtering
      ul
        li bilinear filtering is used on each of the two nearest mipmap levels
      h4 Anisotropic filtering
      ul
        li samples texels within a region corresponding to the view angle
    // ============================================================
    +mframe(bgr, 'Texture filtering')
      .columns-2
        figure.ml80
          img.h350(src='../static/slides/images/lecture08/filtering_none.jpg')
          p Nearesth neighbor
        figure.mr80
          img.h350(src='../static/slides/images/lecture08/filtering_anis.jpg')
          p Anisotropic
      .columns-2
        figure.ml80
          img.h350(src='../static/slides/images/lecture08/filtering_bili.jpg')
          p Bilinear
        figure.mr80
          img.h350(src='../static/slides/images/lecture08/filtering_trili.jpg')
          p Trilinear
    // ============================================================
    +mframeGreen(bgr, 'Antialiasing')
      .bottom-content.justify-right
        img.h600(src='../static/slides/svg/lecture08/antialiasing.svg')
      ul
        li used to smooth sharp edges of vertices
      h4 FSAA/SSAA (Super-Sampled Antialiasing)
      ul
        li uses sub-pixel values to average out the final values
      h4 DSR (Dynamic Super Resolution)
      ul
        li scene si rendered into a frame buffer that is larger than the actual screen
        li oversized image is downsampled
        li the pixel shader is evaluated multiple times per pixel
      h4 MSAA (Multisampled Antialiasing)
      ul
        li comparable to DSR, half of the overhead
        li the pixel shader only needs to be evaluated once per pixel
      h4 MFAA (Multi-frame sampled Antialiasing)
      ul
        li sample locations using MSAA across multiple frames
      h4 CSAA (Coverage sample Antialiasing)
      ul
        li NVidia's optimization of MSAA
        li new sample type: a sample that represents coverage
    // ============================================================
    +mframe(bgr, 'Example: Antialiasing')
      .tcenter
        img.mt80.h700(src='../static/slides/images/lecture08/antialiasing.jpg')
    // ============================================================
    +mframe(bgr, 'Lecture 8 Review')
      ul
        li
          +btext('', 'Rotational representation:', 'Euler angles, Axis + angle, Quaternions')
          ul
            li usually, Euler angles are used for fast rotation around one axis and quaternions for complex yet slow rotations around all axes
        li
          +btext('', 'Spaces:', 'Model space, World space, Clip space, View/screen space')
        li
          +btext('', 'View volume:', 'region of space the camera can see')
        li.mt40
          +btext('', 'Animations:', 'stop-motion animation, keyframed animation')
        li
          +btext('', 'Interpolation:', 'method that calculates points within the range of given points')
        li.mt40
          +btext('', 'Terms:', 'vertex, fragment, texture, texel, shader')
        li
          +btext('', 'Shader:', 'a program that runs on GPU')
          ul
            li vertex shader, geometry shader, tessellation shader, fragment shader, compute shader
    // ============================================================
    +gbquote(bgr, 'Not even death can save you from me!', 'Diablo 2', false)(class="w60")
   

include ./partial/footer.pug
script(src!='../libs/revealjs/revealjs.ts')
script(src!='../src/lectures/reveal-setup.ts')
